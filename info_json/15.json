{
  "id": 15,
  "repo": "cargo-mutants",
  "issue_url": "https://github.com/sourcefrog/cargo-mutants/issues/322",
  "pr_url": "https://github.com/sourcefrog/cargo-mutants/pull/345",
  "issue_description": "I understand why the standard timeout doesn't apply to `cargo build`, but it's possible for a mutation to be made in a `const` function which is evaluated at compile time. This mutation can cause an infinite loop that will then stall the entire pipeline.\r\n\r\nIf there were a separate option for a build timeout, then this could be prevented. Much like the test timeout, this value could be inferred from the baseline build.\r\n\r\nThere are of course workarounds I can use (`--exclude-re`, `#[mutants::skip]`), so this isn't a blocker.",
  "files_changed": [
    {
      "filename": "NEWS.md",
      "status": "modified",
      "patch": "@@ -2,6 +2,12 @@\n \n ## Unreleased\n \n+- New: `--build-timeout` and `--build-timeout-multiplier` options for setting timeouts for the `build` and `check` cargo phases.\n+\n+- Changed: `--timeout-multiplier` now overrides `timeout_multiplier` from `.cargo/mutants.toml`.\n+\n+- Changed: `--timeout` and `--timeout-multiplier` are now conflicting options.\n+\n ## 24.4.0\n \n - Changes: Baselines and mutants are now built with `cargo test --no-run` rather than `cargo build --tests` as previously. This avoids wasted build effort if the `dev` and `test` Cargo profiles are not the same, and may better distinguish build failures from test failures. With `--test-tool=nextest`, the corresponding `cargo nextest run --no-run` is used."
    },
    {
      "filename": "book/src/timeouts.md",
      "status": "modified",
      "patch": "@@ -16,21 +16,35 @@ file](filter_mutants.md).\n \n ## Timeouts\n \n-To avoid hangs, cargo-mutants will kill the test suite after a timeout and\n+To avoid hangs, cargo-mutants will kill the build or test after a timeout and\n continue to the next mutant.\n \n-By default, the timeout is set automatically. cargo-mutants measures the time to\n-run the test suite in the unmodified tree, and then sets a timeout for mutated\n-tests at 5x the time to run tests with no mutations, and a minimum of 20\n-seconds.\n+By default, the timeouts are set automatically, relative to the times taken to\n+build and test the unmodified tree (baseline).\n \n-The minimum of 20 seconds can be overridden by the\n-`CARGO_MUTANTS_MINIMUM_TEST_TIMEOUT` environment variable, measured in seconds.\n+The default timeouts are:\n+- `cargo build`/`cargo check`: 2 times the baseline build time\n+- `cargo test`: 5 times baseline test time (with a minimum of 20 seconds)\n \n-You can also set an explicit timeout with the `--timeout` option, also measured\n-in seconds. If this option is specified then the timeout is also applied to the\n-unmutated tests.\n+The minimum of 20 seconds for the test timeout can be overridden by the\n+`--minimum-test-timeout` option or the `CARGO_MUTANTS_MINIMUM_TEST_TIMEOUT` \n+environment variable, measured in seconds.\n \n-You can set a timeout multiplier that is relative to the duration of the unmutated tests with `--timeout-multiplier` or setting `timeout_multiplier` in `.cargo/mutants.toml` (`timeout-multiplier = 1.5`). This option is only applied if the baseline is not skipped and no `--timeout` option is specified, otherwise it is ignored.\n+You can set explicit timeouts with the `--build-timeout`, and `--timeout`\n+options, also measured in seconds. If these options are specified then they \n+are applied to the baseline build and test as well.\n \n-The timeout does not apply to `cargo check` or `cargo build`, only `cargo test`.\n+You can set timeout multipliers that are relative to the duration of the\n+baseline build or test with `--build-timeout-multiplier` and\n+`--timeout-multiplier`, respectively.  Additionally, these can be configured\n+with `build_timeout_multiplier` and `timeout_multiplier` in\n+`.cargo/mutants.toml` (e.g. `timeout-multiplier = 1.5`).  These options are only\n+applied if the baseline is not skipped and no corresponding\n+`--build-timeout`/`--timeout` option is specified, otherwise they are ignored.\n+\n+## Exceptions\n+\n+The multiplier timeout options cannot be used when the baseline is skipped\n+(`--baseline=skip`), or when the build is in-place (`--in-place`). If no \n+explicit timeouts is provided in these cases, then a default of 300 seconds\n+will be used."
    },
    {
      "filename": "src/config.rs",
      "status": "modified",
      "patch": "@@ -47,6 +47,8 @@ pub struct Config {\n     pub test_tool: Option<TestTool>,\n     /// Timeout multiplier, relative to the baseline 'cargo test'.\n     pub timeout_multiplier: Option<f64>,\n+    /// Build timeout multiplier, relative to the baseline 'cargo build'.\n+    pub build_timeout_multiplier: Option<f64>,\n }\n \n impl Config {"
    },
    {
      "filename": "src/lab.rs",
      "status": "modified",
      "patch": "@@ -65,7 +65,10 @@ pub fn test_mutants(\n                 &output_mutex,\n                 &Scenario::Baseline,\n                 &all_packages,\n-                options.test_timeout.unwrap_or(Duration::MAX),\n+                Timeouts {\n+                    test: options.test_timeout.unwrap_or(Duration::MAX),\n+                    build: options.build_timeout.unwrap_or(Duration::MAX),\n+                },\n                 &options,\n                 console,\n             )?;\n@@ -86,12 +89,17 @@ pub fn test_mutants(\n         BaselineStrategy::Skip => None,\n     };\n     let mut build_dirs = vec![build_dir];\n-    let baseline_test_duration = baseline_outcome\n-        .as_ref()\n-        .and_then(|so| so.phase_result(Phase::Test))\n-        .map(|pr| pr.duration);\n \n-    let test_timeout = test_timeout(baseline_test_duration, &options);\n+    let baseline_duration_by_phase = |phase| {\n+        baseline_outcome\n+            .as_ref()\n+            .and_then(|so| so.phase_result(phase))\n+            .map(|pr| pr.duration)\n+    };\n+    let timeouts = Timeouts {\n+        build: build_timeout(baseline_duration_by_phase(Phase::Build), &options),\n+        test: test_timeout(baseline_duration_by_phase(Phase::Test), &options),\n+    };\n \n     let jobs = max(1, min(options.jobs.unwrap_or(1), mutants.len()));\n     for i in 1..jobs {\n@@ -134,7 +142,7 @@ pub fn test_mutants(\n                                 &output_mutex,\n                                 &Scenario::Mutant(mutant),\n                                 &[&package],\n-                                test_timeout,\n+                                timeouts,\n                                 &options,\n                                 console,\n                             )?;\n@@ -190,33 +198,78 @@ pub fn test_mutants(\n     Ok(lab_outcome)\n }\n \n-fn test_timeout(baseline_test_duration: Option<Duration>, options: &Options) -> Duration {\n-    if let Some(timeout) = options.test_timeout {\n-        timeout\n-    } else if options.check_only {\n-        Duration::ZERO\n-    } else if let Some(baseline_test_duration) = baseline_test_duration {\n-        let timeout = max(\n-            options.minimum_test_timeout,\n-            Duration::from_secs(\n-                (baseline_test_duration.as_secs_f64()\n-                    * options.test_timeout_multiplier.unwrap_or(5.0))\n-                .round() as u64,\n-            ),\n-        );\n-        if options.show_times {\n-            info!(\n-                \"Auto-set test timeout to {}\",\n-                humantime::format_duration(timeout)\n+#[derive(Copy, Clone)]\n+struct Timeouts {\n+    build: Duration,\n+    test: Duration,\n+}\n+\n+fn phase_timeout(\n+    phase: Phase,\n+    explicit_timeout: Option<Duration>,\n+    baseline_duration: Option<Duration>,\n+    minimum: Duration,\n+    multiplier: f64,\n+    options: &Options,\n+) -> Duration {\n+    const FALLBACK_TIMEOUT_SECS: u64 = 300;\n+    fn warn_fallback_timeout(phase_name: &str, option: &str) {\n+        warn!(\"An explicit {phase_name} timeout is recommended when using {option}; using {FALLBACK_TIMEOUT_SECS} seconds by default\");\n+    }\n+\n+    if let Some(timeout) = explicit_timeout {\n+        return timeout;\n+    }\n+\n+    match baseline_duration {\n+        Some(_) if options.in_place && phase != Phase::Test => {\n+            warn_fallback_timeout(phase.name(), \"--in-place\");\n+            Duration::from_secs(FALLBACK_TIMEOUT_SECS)\n+        }\n+        Some(baseline_duration) => {\n+            let timeout = max(\n+                minimum,\n+                Duration::from_secs((baseline_duration.as_secs_f64() * multiplier).ceil() as u64),\n             );\n+\n+            if options.show_times {\n+                info!(\n+                    \"Auto-set {} timeout to {}\",\n+                    phase.name(),\n+                    humantime::format_duration(timeout)\n+                );\n+            }\n+            timeout\n+        }\n+        None => {\n+            warn_fallback_timeout(phase.name(), \"--baseline=skip\");\n+            Duration::from_secs(FALLBACK_TIMEOUT_SECS)\n         }\n-        timeout\n-    } else {\n-        warn!(\"An explicit timeout is recommended when using --baseline=skip; using 300 seconds by default\");\n-        Duration::from_secs(300)\n     }\n }\n \n+fn test_timeout(baseline_duration: Option<Duration>, options: &Options) -> Duration {\n+    phase_timeout(\n+        Phase::Test,\n+        options.test_timeout,\n+        baseline_duration,\n+        options.minimum_test_timeout,\n+        options.test_timeout_multiplier.unwrap_or(5.0),\n+        options,\n+    )\n+}\n+\n+fn build_timeout(baseline_duration: Option<Duration>, options: &Options) -> Duration {\n+    phase_timeout(\n+        Phase::Build,\n+        options.build_timeout,\n+        baseline_duration,\n+        Duration::ZERO,\n+        options.build_timeout_multiplier.unwrap_or(2.0),\n+        options,\n+    )\n+}\n+\n /// Test various phases of one scenario in a build dir.\n ///\n /// The [BuildDir] is passed as mutable because it's for the exclusive use of this function for the\n@@ -226,7 +279,7 @@ fn test_scenario(\n     output_mutex: &Mutex<OutputDir>,\n     scenario: &Scenario,\n     test_packages: &[&Package],\n-    test_timeout: Duration,\n+    timeouts: Timeouts,\n     options: &Options,\n     console: &Console,\n ) -> Result<ScenarioOutcome> {\n@@ -255,8 +308,8 @@ fn test_scenario(\n     for &phase in phases {\n         console.scenario_phase_started(scenario, phase);\n         let timeout = match phase {\n-            Phase::Test => test_timeout,\n-            _ => Duration::MAX,\n+            Phase::Test => timeouts.test,\n+            Phase::Build | Phase::Check => timeouts.build,\n         };\n         let phase_result = run_cargo(\n             build_dir,\n@@ -306,6 +359,40 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn test_timeout_unaffected_by_in_place_build() {\n+        let args = Args::parse_from([\"mutants\", \"--timeout-multiplier\", \"1.5\", \"--in-place\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(\n+            test_timeout(Some(Duration::from_secs(40)), &options),\n+            Duration::from_secs(60),\n+        );\n+    }\n+\n+    #[test]\n+    fn build_timeout_multiplier_from_option() {\n+        let args = Args::parse_from([\"mutants\", \"--build-timeout-multiplier\", \"1.5\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(options.build_timeout_multiplier, Some(1.5));\n+        assert_eq!(\n+            build_timeout(Some(Duration::from_secs(40)), &options),\n+            Duration::from_secs(60),\n+        );\n+    }\n+\n+    #[test]\n+    fn build_timeout_is_affected_by_in_place_build() {\n+        let args = Args::parse_from([\"mutants\", \"--build-timeout-multiplier\", \"1.5\", \"--in-place\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(\n+            build_timeout(Some(Duration::from_secs(40)), &options),\n+            Duration::from_secs(300),\n+        );\n+    }\n+\n     #[test]\n     fn timeout_multiplier_from_config() {\n         let args = Args::parse_from([\"mutants\"]);\n@@ -322,6 +409,22 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn build_timeout_multiplier_from_config() {\n+        let args = Args::parse_from([\"mutants\"]);\n+        let config = Config::from_str(indoc! {r#\"\n+            build_timeout_multiplier = 2.0\n+        \"#})\n+        .unwrap();\n+        let options = Options::new(&args, &config).unwrap();\n+\n+        assert_eq!(options.build_timeout_multiplier, Some(2.0));\n+        assert_eq!(\n+            build_timeout(Some(Duration::from_secs(42)), &options),\n+            Duration::from_secs(42 * 2),\n+        );\n+    }\n+\n     #[test]\n     fn timeout_multiplier_default() {\n         let args = Args::parse_from([\"mutants\"]);\n@@ -334,6 +437,34 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn build_timeout_multiplier_default() {\n+        let args = Args::parse_from([\"mutants\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(options.build_timeout_multiplier, None);\n+        assert_eq!(\n+            build_timeout(Some(Duration::from_secs(42)), &options),\n+            Duration::from_secs(42 * 2),\n+        );\n+    }\n+\n+    #[test]\n+    fn timeout_from_option() {\n+        let args = Args::parse_from([\"mutants\", \"--timeout=8\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(options.test_timeout, Some(Duration::from_secs(8)));\n+    }\n+\n+    #[test]\n+    fn build_timeout_from_option() {\n+        let args = Args::parse_from([\"mutants\", \"--build-timeout=4\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(options.build_timeout, Some(Duration::from_secs(4)));\n+    }\n+\n     #[test]\n     fn timeout_multiplier_default_with_baseline_skip() {\n         // The --baseline option is not used to set the timeout but it's\n@@ -344,4 +475,15 @@ mod test {\n         assert_eq!(options.test_timeout_multiplier, None);\n         assert_eq!(test_timeout(None, &options), Duration::from_secs(300),);\n     }\n+\n+    #[test]\n+    fn build_timeout_multiplier_default_with_baseline_skip() {\n+        // The --baseline option is not used to set the timeout but it's\n+        // indicative of the realistic situation.\n+        let args = Args::parse_from([\"mutants\", \"--baseline\", \"skip\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+\n+        assert_eq!(options.build_timeout_multiplier, None);\n+        assert_eq!(build_timeout(None, &options), Duration::from_secs(300),);\n+    }\n }"
    },
    {
      "filename": "src/main.rs",
      "status": "modified",
      "patch": "@@ -289,9 +289,17 @@ pub struct Args {\n     timeout: Option<f64>,\n \n     /// Test timeout multiplier (relative to base test time).\n-    #[arg(long, help_heading = \"Execution\")]\n+    #[arg(long, help_heading = \"Execution\", conflicts_with = \"timeout\")]\n     timeout_multiplier: Option<f64>,\n \n+    /// Maximum run time for cargo build command, in seconds.\n+    #[arg(long, help_heading = \"Execution\")]\n+    build_timeout: Option<f64>,\n+\n+    /// Build timeout multiplier (relative to base build time).\n+    #[arg(long, help_heading = \"Execution\", conflicts_with = \"build_timeout\")]\n+    build_timeout_multiplier: Option<f64>,\n+\n     /// Print mutations that failed to check or build.\n     #[arg(long, short = 'V', help_heading = \"Output\")]\n     unviable: bool,"
    },
    {
      "filename": "src/options.rs",
      "status": "modified",
      "patch": "@@ -46,6 +46,16 @@ pub struct Options {\n     /// The time multiplier for test tasks, if set (relative to baseline test duration).\n     pub test_timeout_multiplier: Option<f64>,\n \n+    /// The time limit for build tasks, if set.\n+    ///\n+    /// If this is not set by the user it's None, in which case there is no time limit\n+    /// on the baseline build, and then the mutated builds get a multiple of the time\n+    /// taken by the baseline build.\n+    pub build_timeout: Option<Duration>,\n+\n+    /// The time multiplier for build tasks, if set (relative to baseline build duration).\n+    pub build_timeout_multiplier: Option<f64>,\n+\n     /// The minimum test timeout, as a floor on the autoset value.\n     pub minimum_test_timeout: Duration,\n \n@@ -211,7 +221,11 @@ impl Options {\n             show_times: !args.no_times,\n             show_all_logs: args.all_logs,\n             test_timeout: args.timeout.map(Duration::from_secs_f64),\n-            test_timeout_multiplier: config.timeout_multiplier.or(args.timeout_multiplier),\n+            test_timeout_multiplier: args.timeout_multiplier.or(config.timeout_multiplier),\n+            build_timeout: args.build_timeout.map(Duration::from_secs_f64),\n+            build_timeout_multiplier: args\n+                .build_timeout_multiplier\n+                .or(config.build_timeout_multiplier),\n             test_tool: args.test_tool.or(config.test_tool).unwrap_or_default(),\n         };\n         options.error_values.iter().for_each(|e| {\n@@ -280,6 +294,69 @@ mod test {\n         assert_eq!(options.baseline, BaselineStrategy::Run);\n     }\n \n+    #[test]\n+    fn options_from_timeout_args() {\n+        let args = Args::parse_from([\"mutants\", \"--timeout=2.0\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+        assert_eq!(options.test_timeout, Some(Duration::from_secs(2)));\n+\n+        let args = Args::parse_from([\"mutants\", \"--timeout-multiplier=2.5\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+        assert_eq!(options.test_timeout_multiplier, Some(2.5));\n+\n+        let args = Args::parse_from([\"mutants\", \"--minimum-test-timeout=60.0\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+        assert_eq!(options.minimum_test_timeout, Duration::from_secs(60));\n+\n+        let args = Args::parse_from([\"mutants\", \"--build-timeout=3.0\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+        assert_eq!(options.build_timeout, Some(Duration::from_secs(3)));\n+\n+        let args = Args::parse_from([\"mutants\", \"--build-timeout-multiplier=3.5\"]);\n+        let options = Options::new(&args, &Config::default()).unwrap();\n+        assert_eq!(options.build_timeout_multiplier, Some(3.5));\n+    }\n+\n+    #[test]\n+    fn cli_timeout_multiplier_overrides_config() {\n+        let config = indoc! { r#\"\n+            timeout_multiplier = 1.0\n+            build_timeout_multiplier = 2.0\n+        \"#};\n+        let mut config_file = NamedTempFile::new().unwrap();\n+        config_file.write_all(config.as_bytes()).unwrap();\n+        let args = Args::parse_from([\n+            \"mutants\",\n+            \"--timeout-multiplier=2.0\",\n+            \"--build-timeout-multiplier=1.0\",\n+        ]);\n+        let config = Config::read_file(config_file.path()).unwrap();\n+        let options = Options::new(&args, &config).unwrap();\n+\n+        assert_eq!(options.test_timeout_multiplier, Some(2.0));\n+        assert_eq!(options.build_timeout_multiplier, Some(1.0));\n+    }\n+\n+    #[test]\n+    fn conflicting_timeout_options() {\n+        let args = Args::try_parse_from([\"mutants\", \"--timeout=1\", \"--timeout-multiplier=1\"])\n+            .expect_err(\"--timeout and --timeout-multiplier should conflict\");\n+        let rendered = format!(\"{}\", args.render());\n+        assert!(rendered.contains(\"error: the argument '--timeout <TIMEOUT>' cannot be used with '--timeout-multiplier <TIMEOUT_MULTIPLIER>'\"));\n+    }\n+\n+    #[test]\n+    fn conflicting_build_timeout_options() {\n+        let args = Args::try_parse_from([\n+            \"mutants\",\n+            \"--build-timeout=1\",\n+            \"--build-timeout-multiplier=1\",\n+        ])\n+        .expect_err(\"--build-timeout and --build-timeout-multiplier should conflict\");\n+        let rendered = format!(\"{}\", args.render());\n+        assert!(rendered.contains(\"error: the argument '--build-timeout <BUILD_TIMEOUT>' cannot be used with '--build-timeout-multiplier <BUILD_TIMEOUT_MULTIPLIER>'\"));\n+    }\n+\n     #[test]\n     fn test_tool_from_config() {\n         let config = indoc! { r#\""
    },
    {
      "filename": "testdata/hang_when_mutated/src/lib.rs",
      "status": "modified",
      "patch": "@@ -8,6 +8,18 @@ use std::time::{Duration, Instant};\n \n static TRIGGER: AtomicBool = AtomicBool::new(false);\n \n+const fn should_stop_const() -> bool {\n+    true\n+}\n+\n+/// If `should_stop_const` is mutated to return false, then this const block\n+/// will hang and block compilation.\n+pub const VAL: i32 = loop {\n+    if should_stop_const() {\n+        break 1;\n+    }\n+};\n+\n /// If mutated to return false, the program will spin forever.\n fn should_stop() -> bool {\n     if TRIGGER.load(Ordering::Relaxed) {\n@@ -44,4 +56,9 @@ mod test {\n         // then the trigger is true and the loop terminates.\n         assert_eq!(super::controlled_loop(), 2);\n     }\n+\n+    #[test]\n+    fn val_is_correct() {\n+        assert_eq!(super::VAL, 1);\n+    }\n }"
    },
    {
      "filename": "tests/main.rs",
      "status": "modified",
      "patch": "@@ -162,8 +162,11 @@ fn test_small_well_tested_tree_with_baseline_skip() {\n         }))\n         .stderr(\n             predicate::str::contains(\n-                \"An explicit timeout is recommended when using --baseline=skip\",\n+                \"An explicit test timeout is recommended when using --baseline=skip\",\n             )\n+            .and(predicate::str::contains(\n+                \"An explicit build timeout is recommended when using --baseline=skip\",\n+            ))\n             .and(predicate::str::contains(\"Unmutated baseline in\").not()),\n         );\n     assert!(!tmp_src_dir\n@@ -734,33 +737,32 @@ fn interrupt_caught_and_kills_children() {\n /// * `should_stop` could change to always return `false`, in which case\n ///   the loop will never stop, but the test should eventually be killed\n ///   by a timeout.\n+///\n+/// * `should_stop_const` could change to always return `false`, in which\n+///   case the loop in the block for the const `VAL` will never stop, but\n+///   the build should eventually be killed by a timeout.\n #[test]\n fn mutants_causing_tests_to_hang_are_stopped_by_manual_timeout() {\n     let tmp_src_dir = copy_of_testdata(\"hang_when_mutated\");\n     // Also test that it accepts decimal seconds\n     run()\n         .arg(\"mutants\")\n-        .args([\n-            \"-t\",\n-            \"8.1\",\n-            \"-v\",\n-            \"--line-col=false\",\n-            \"--\",\n-            \"--\",\n-            \"--nocapture\",\n-        ])\n+        .args([\"-t\", \"8.1\"])\n         .current_dir(tmp_src_dir.path())\n         .env_remove(\"RUST_BACKTRACE\")\n         .timeout(OUTER_TIMEOUT)\n         .assert()\n-        .code(3) // exit_code::TIMEOUT\n-        ;\n+        .code(3); // exit_code::TIMEOUT\n     let timeout_txt = read_to_string(tmp_src_dir.path().join(\"mutants.out/timeout.txt\"))\n         .expect(\"read timeout.txt\");\n     assert!(\n         timeout_txt.contains(\"replace should_stop -> bool with false\"),\n         \"expected text not found in:\\n{timeout_txt}\"\n     );\n+    assert!(\n+        timeout_txt.contains(\"replace should_stop_const -> bool with false\"),\n+        \"expected text not found in:\\n{timeout_txt}\"\n+    );\n     let caught_txt = read_to_string(tmp_src_dir.path().join(\"mutants.out/caught.txt\")).unwrap();\n     assert!(\n         caught_txt.contains(\"replace should_stop -> bool with true\"),\n@@ -775,7 +777,40 @@ fn mutants_causing_tests_to_hang_are_stopped_by_manual_timeout() {\n             .expect(\"read outcomes.json\")\n             .parse()\n             .expect(\"parse outcomes.json\");\n-    assert_eq!(outcomes_json[\"timeout\"], 1);\n+    assert_eq!(outcomes_json[\"timeout\"], 2);\n+\n+    let phases_for_const_fn = outcomes_json[\"outcomes\"]\n+        .as_array()\n+        .unwrap()\n+        .iter()\n+        .filter(|outcome| {\n+            outcome[\"scenario\"][\"Mutant\"][\"function\"][\"function_name\"] == \"should_stop_const\"\n+        })\n+        .flat_map(|outcome| outcome[\"phase_results\"].as_array())\n+        .next()\n+        .expect(\"Failed to find phase_results for 'should_stop_const' fn\");\n+\n+    assert_eq!(phases_for_const_fn.len(), 1);\n+    assert_eq!(phases_for_const_fn[0][\"phase\"], \"Build\");\n+}\n+\n+#[test]\n+fn mutants_causing_check_to_timeout_are_stopped_by_manual_timeout() {\n+    let tmp_src_dir = copy_of_testdata(\"hang_when_mutated\");\n+    run()\n+        .arg(\"mutants\")\n+        .args([\"--check\", \"--build-timeout=4\"])\n+        .current_dir(tmp_src_dir.path())\n+        .env_remove(\"RUST_BACKTRACE\")\n+        .timeout(OUTER_TIMEOUT)\n+        .assert()\n+        .code(3); // exit_code::TIMEOUT\n+    let timeout_txt = read_to_string(tmp_src_dir.path().join(\"mutants.out/timeout.txt\"))\n+        .expect(\"read timeout.txt\");\n+    assert!(\n+        timeout_txt.contains(\"replace should_stop_const -> bool with false\"),\n+        \"expected text not found in:\\n{timeout_txt}\"\n+    );\n }\n \n #[test]"
    },
    {
      "filename": "tests/snapshots/list__list_mutants_in_all_trees_as_json.snap",
      "status": "modified",
      "patch": "@@ -1618,12 +1618,12 @@ expression: buf\n   {\n     \"file\": \"src/lib.rs\",\n     \"function\": {\n-      \"function_name\": \"should_stop\",\n+      \"function_name\": \"should_stop_const\",\n       \"return_type\": \"-> bool\",\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 18\n+          \"line\": 13\n         },\n         \"start\": {\n           \"column\": 1,\n@@ -1633,15 +1633,45 @@ expression: buf\n     },\n     \"genre\": \"FnValue\",\n     \"package\": \"cargo-mutants-testdata-hang-when-mutated\",\n+    \"replacement\": \"false\",\n+    \"span\": {\n+      \"end\": {\n+        \"column\": 9,\n+        \"line\": 12\n+      },\n+      \"start\": {\n+        \"column\": 5,\n+        \"line\": 12\n+      }\n+    }\n+  },\n+  {\n+    \"file\": \"src/lib.rs\",\n+    \"function\": {\n+      \"function_name\": \"should_stop\",\n+      \"return_type\": \"-> bool\",\n+      \"span\": {\n+        \"end\": {\n+          \"column\": 2,\n+          \"line\": 30\n+        },\n+        \"start\": {\n+          \"column\": 1,\n+          \"line\": 23\n+        }\n+      }\n+    },\n+    \"genre\": \"FnValue\",\n+    \"package\": \"cargo-mutants-testdata-hang-when-mutated\",\n     \"replacement\": \"true\",\n     \"span\": {\n       \"end\": {\n         \"column\": 10,\n-        \"line\": 17\n+        \"line\": 29\n       },\n       \"start\": {\n         \"column\": 5,\n-        \"line\": 13\n+        \"line\": 25\n       }\n     }\n   },\n@@ -1653,11 +1683,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 18\n+          \"line\": 30\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 11\n+          \"line\": 23\n         }\n       }\n     },\n@@ -1667,11 +1697,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 10,\n-        \"line\": 17\n+        \"line\": 29\n       },\n       \"start\": {\n         \"column\": 5,\n-        \"line\": 13\n+        \"line\": 25\n       }\n     }\n   },\n@@ -1683,11 +1713,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 38\n+          \"line\": 50\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 20\n+          \"line\": 32\n         }\n       }\n     },\n@@ -1697,11 +1727,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 20,\n-        \"line\": 37\n+        \"line\": 49\n       },\n       \"start\": {\n         \"column\": 5,\n-        \"line\": 26\n+        \"line\": 38\n       }\n     }\n   },\n@@ -1713,11 +1743,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 38\n+          \"line\": 50\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 20\n+          \"line\": 32\n         }\n       }\n     },\n@@ -1727,11 +1757,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 20,\n-        \"line\": 37\n+        \"line\": 49\n       },\n       \"start\": {\n         \"column\": 5,\n-        \"line\": 26\n+        \"line\": 38\n       }\n     }\n   },\n@@ -1743,11 +1773,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 38\n+          \"line\": 50\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 20\n+          \"line\": 32\n         }\n       }\n     },\n@@ -1757,11 +1787,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 29,\n-        \"line\": 33\n+        \"line\": 45\n       },\n       \"start\": {\n         \"column\": 28,\n-        \"line\": 33\n+        \"line\": 45\n       }\n     }\n   },\n@@ -1773,11 +1803,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 38\n+          \"line\": 50\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 20\n+          \"line\": 32\n         }\n       }\n     },\n@@ -1787,11 +1817,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 29,\n-        \"line\": 33\n+        \"line\": 45\n       },\n       \"start\": {\n         \"column\": 28,\n-        \"line\": 33\n+        \"line\": 45\n       }\n     }\n   },\n@@ -1803,11 +1833,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 38\n+          \"line\": 50\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 20\n+          \"line\": 32\n         }\n       }\n     },\n@@ -1817,11 +1847,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 54,\n-        \"line\": 33\n+        \"line\": 45\n       },\n       \"start\": {\n         \"column\": 53,\n-        \"line\": 33\n+        \"line\": 45\n       }\n     }\n   },\n@@ -1833,11 +1863,11 @@ expression: buf\n       \"span\": {\n         \"end\": {\n           \"column\": 2,\n-          \"line\": 38\n+          \"line\": 50\n         },\n         \"start\": {\n           \"column\": 1,\n-          \"line\": 20\n+          \"line\": 32\n         }\n       }\n     },\n@@ -1847,11 +1877,11 @@ expression: buf\n     \"span\": {\n       \"end\": {\n         \"column\": 54,\n-        \"line\": 33\n+        \"line\": 45\n       },\n       \"start\": {\n         \"column\": 53,\n-        \"line\": 33\n+        \"line\": 45\n       }\n     }\n   }"
    },
    {
      "filename": "tests/snapshots/list__list_mutants_in_all_trees_as_text.snap",
      "status": "modified",
      "patch": "@@ -135,14 +135,15 @@ src/lib.rs:21:53: replace * with / in controlled_loop\n ## testdata/hang_when_mutated\n \n ```\n-src/lib.rs:13:5: replace should_stop -> bool with true\n-src/lib.rs:13:5: replace should_stop -> bool with false\n-src/lib.rs:26:5: replace controlled_loop -> usize with 0\n-src/lib.rs:26:5: replace controlled_loop -> usize with 1\n-src/lib.rs:33:28: replace > with == in controlled_loop\n-src/lib.rs:33:28: replace > with < in controlled_loop\n-src/lib.rs:33:53: replace * with + in controlled_loop\n-src/lib.rs:33:53: replace * with / in controlled_loop\n+src/lib.rs:12:5: replace should_stop_const -> bool with false\n+src/lib.rs:25:5: replace should_stop -> bool with true\n+src/lib.rs:25:5: replace should_stop -> bool with false\n+src/lib.rs:38:5: replace controlled_loop -> usize with 0\n+src/lib.rs:38:5: replace controlled_loop -> usize with 1\n+src/lib.rs:45:28: replace > with == in controlled_loop\n+src/lib.rs:45:28: replace > with < in controlled_loop\n+src/lib.rs:45:53: replace * with + in controlled_loop\n+src/lib.rs:45:53: replace * with / in controlled_loop\n ```\n \n ## testdata/insta"
    },
    {
      "filename": "tests/snapshots/main__well_tested_tree_with_short_build_timeout__caught.txt.snap",
      "status": "added",
      "patch": "@@ -0,0 +1,5 @@\n+---\n+source: tests/main.rs\n+expression: content\n+---\n+"
    },
    {
      "filename": "tests/snapshots/main__well_tested_tree_with_short_build_timeout__missed.txt.snap",
      "status": "added",
      "patch": "@@ -0,0 +1,5 @@\n+---\n+source: tests/main.rs\n+expression: content\n+---\n+"
    },
    {
      "filename": "tests/snapshots/main__well_tested_tree_with_short_build_timeout__timeout.txt.snap",
      "status": "added",
      "patch": "@@ -0,0 +1,70 @@\n+---\n+source: tests/main.rs\n+expression: content\n+---\n+src/slices.rs:13:5: replace return_mut_slice -> &mut[usize] with Vec::leak(vec![0])\n+src/numbers.rs:6:5: replace is_double -> bool with false\n+src/simple_fns.rs:13:5: replace returns_42u32 -> u32 with 1\n+src/arc.rs:4:5: replace return_arc -> Arc<String> with Arc::new(String::new())\n+src/nested_function.rs:5:13: replace * with + in has_nested\n+src/numbers.rs:6:7: replace == with != in is_double\n+src/nested_function.rs:2:5: replace has_nested -> u32 with 1\n+src/slices.rs:14:12: replace *= with /= in return_mut_slice\n+src/simple_fns.rs:8:5: replace returns_unit with ()\n+src/nested_function.rs:3:9: replace has_nested::inner -> u32 with 1\n+src/simple_fns.rs:18:5: replace divisible_by_three -> bool with true\n+src/simple_fns.rs:8:8: replace += with -= in returns_unit\n+src/simple_fns.rs:18:7: replace % with + in divisible_by_three\n+src/numbers.rs:2:9: replace * with + in double_float\n+src/numbers.rs:6:12: replace * with / in is_double\n+src/nested_function.rs:3:9: replace has_nested::inner -> u32 with 0\n+src/numbers.rs:2:5: replace double_float -> f32 with 1.0\n+src/simple_fns.rs:18:5: replace divisible_by_three -> bool with false\n+src/simple_fns.rs:18:11: replace == with != in divisible_by_three\n+src/simple_fns.rs:18:7: replace % with / in divisible_by_three\n+src/slices.rs:14:12: replace *= with += in return_mut_slice\n+src/static_item.rs:1:33: replace == with !=\n+src/simple_fns.rs:27:5: replace double_string -> String with \"xyzzy\".into()\n+src/slices.rs:4:5: replace pad -> &'a[Cow<'static, str>] with Vec::leak(Vec::new())\n+src/methods.rs:17:9: replace Foo::double with ()\n+src/nested_function.rs:5:13: replace * with / in has_nested\n+src/result.rs:6:5: replace simple_result -> Result<&'static str, ()> with Ok(\"\")\n+src/arc.rs:4:5: replace return_arc -> Arc<String> with Arc::new(\"xyzzy\".into())\n+src/simple_fns.rs:8:8: replace += with *= in returns_unit\n+src/slices.rs:13:5: replace return_mut_slice -> &mut[usize] with Vec::leak(Vec::new())\n+src/methods.rs:17:16: replace *= with += in Foo::double\n+src/numbers.rs:2:5: replace double_float -> f32 with -1.0\n+src/slices.rs:4:5: replace pad -> &'a[Cow<'static, str>] with Vec::leak(vec![Cow::Owned(\"\".to_owned())])\n+src/slices.rs:4:5: replace pad -> &'a[Cow<'static, str>] with Vec::leak(vec![Cow::Owned(\"xyzzy\".to_owned())])\n+src/numbers.rs:2:5: replace double_float -> f32 with 0.0\n+src/slices.rs:4:5: replace pad -> &'a[Cow<'static, str>] with Vec::leak(vec![Cow::Borrowed(\"\")])\n+src/numbers.rs:2:9: replace * with / in double_float\n+src/numbers.rs:6:12: replace * with + in is_double\n+src/methods.rs:23:9: replace <impl Display for Foo>::fmt -> fmt::Result with Ok(Default::default())\n+src/traits.rs:5:9: replace Something::is_three -> bool with true\n+src/slices.rs:5:20: replace < with > in pad\n+src/result.rs:6:5: replace simple_result -> Result<&'static str, ()> with Ok(\"xyzzy\")\n+src/result.rs:10:10: replace < with == in error_if_negative\n+src/numbers.rs:6:5: replace is_double -> bool with true\n+src/methods.rs:17:16: replace *= with /= in Foo::double\n+src/struct_with_lifetime.rs:15:9: replace Lex<'buf>::buf_len -> usize with 1\n+src/slices.rs:4:5: replace pad -> &'a[Cow<'static, str>] with Vec::leak(vec![Cow::Borrowed(\"xyzzy\")])\n+src/nested_function.rs:2:5: replace has_nested -> u32 with 0\n+src/sets.rs:4:5: replace make_a_set -> BTreeSet<String> with BTreeSet::from_iter([String::new()])\n+src/slices.rs:5:20: replace < with == in pad\n+src/methods.rs:29:9: replace <impl Debug for &Foo>::fmt -> fmt::Result with Ok(Default::default())\n+src/struct_with_lifetime.rs:15:9: replace Lex<'buf>::buf_len -> usize with 0\n+src/simple_fns.rs:27:5: replace double_string -> String with String::new()\n+src/sets.rs:4:5: replace make_a_set -> BTreeSet<String> with BTreeSet::new()\n+src/result.rs:10:5: replace error_if_negative -> Result<(), ()> with Ok(())\n+src/result.rs:18:5: replace result_with_no_apparent_type_args -> std::fmt::Result with Ok(Default::default())\n+src/simple_fns.rs:13:5: replace returns_42u32 -> u32 with 0\n+src/sets.rs:4:5: replace make_a_set -> BTreeSet<String> with BTreeSet::from_iter([\"xyzzy\".into()])\n+src/static_item.rs:1:39: replace + with -\n+src/static_item.rs:1:39: replace + with *\n+src/traits.rs:5:9: replace Something::is_three -> bool with false\n+src/traits.rs:5:11: replace == with != in Something::is_three\n+src/slices.rs:13:5: replace return_mut_slice -> &mut[usize] with Vec::leak(vec![1])\n+src/inside_mod.rs:4:13: replace outer::inner::name -> &'static str with \"\"\n+src/result.rs:10:10: replace < with > in error_if_negative\n+src/inside_mod.rs:4:13: replace outer::inner::name -> &'static str with \"xyzzy\""
    },
    {
      "filename": "tests/snapshots/main__well_tested_tree_with_short_build_timeout__unviable.txt.snap",
      "status": "added",
      "patch": "@@ -0,0 +1,5 @@\n+---\n+source: tests/main.rs\n+expression: content\n+---\n+"
    }
  ],
  "fix_category": NaN,
  "root_cause_category": NaN,
  "root_cause_subcategory": "Meta"
}