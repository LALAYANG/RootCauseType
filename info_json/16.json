{
  "id": 16,
  "repo": "sudo-rs",
  "issue_url": "https://github.com/trifectatechfoundation/sudo-rs/issues/889",
  "pr_url": "https://github.com/trifectatechfoundation/sudo-rs/pull/890",
  "issue_description": "After the merger of #887 (which passed the CI while being 'up to date' with `main`, which is now the rule since the merge queue was disabled), CI on `main` seems to be consistently failing. \r\n\r\nTwo possibilities:\r\n- This can be related to whatever #887 touched (timestamping seems implicated), and we may have observed a \"flaky success\"?\r\n- ~~We have made the CI more flaky by removing all the caching.~~",
  "files_changed": [
    {
      "filename": "src/system/mod.rs",
      "status": "modified",
      "patch": "@@ -600,7 +600,7 @@ impl Process {\n     /// attached to the given process\n     pub fn tty_device_id(pid: WithProcess) -> std::io::Result<Option<DeviceId>> {\n         // device id of tty is displayed as a signed integer of 32 bits\n-        let data: i32 = read_proc_stat(pid, 7 /* tty_nr */)?;\n+        let data: i32 = read_proc_stat(pid, 6 /* tty_nr */)?;\n         if data == 0 {\n             Ok(None)\n         } else {\n@@ -615,7 +615,7 @@ impl Process {\n \n     /// Get the process starting time of a specific process\n     pub fn starting_time(pid: WithProcess) -> io::Result<SystemTime> {\n-        let process_start: u64 = read_proc_stat(pid, 22 /* start_time */)?;\n+        let process_start: u64 = read_proc_stat(pid, 21 /* start_time */)?;\n \n         // the startime field is stored in ticks since the system start, so we need to know how many\n         // ticks go into a second\n@@ -634,13 +634,19 @@ impl Process {\n     }\n }\n \n-/// Read the n-th field (with 1-based indexing) from `/proc/<pid>/self`.\n+/// Read the n-th field (with 0-based indexing) from `/proc/<pid>/self`.\n ///\n /// See [\"Table 1-4: Contents of the stat fields\" of \"The /proc\n /// Filesystem\"][proc_stat_fields] in the Linux docs for all available fields.\n ///\n+/// IMPORTANT: the first two fields are not accessible with this routine.\n+///\n /// [proc_stat_fields]: https://www.kernel.org/doc/html/latest/filesystems/proc.html#id10\n fn read_proc_stat<T: FromStr>(pid: WithProcess, field_idx: isize) -> io::Result<T> {\n+    // the first two fields are skipped by the code below, and we never need them,\n+    // so no point in implementing code for it in this private function.\n+    debug_assert!(field_idx >= 2);\n+\n     // read from a specific pid file, or use `self` to refer to our own process\n     let pidref = pid.to_proc_string();\n \n@@ -661,7 +667,7 @@ fn read_proc_stat<T: FromStr>(pid: WithProcess, field_idx: isize) -> io::Result<\n     // we've now passed the first two fields, so we are at index 1, now we skip over\n     // fields until we arrive at the field we are searching for\n     let mut curr_field = 1;\n-    while curr_field <= field_idx && !stat.is_empty() {\n+    while curr_field < field_idx && !stat.is_empty() {\n         if stat[0] == b' ' {\n             curr_field += 1;\n         }\n@@ -960,4 +966,17 @@ mod tests {\n         let (_, status) = child_pid.wait(WaitOptions::new()).unwrap();\n         assert_eq!(status.exit_status(), Some(0));\n     }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[test]\n+    fn proc_stat_test() {\n+        use super::{read_proc_stat, Process, WithProcess::Current};\n+        // the process is 'sleeping' (apparently)\n+        assert_eq!(\"S\", read_proc_stat::<String>(Current, 2).unwrap());\n+        let parent = Process::parent_id().unwrap();\n+        // field 3 is always the parent process\n+        assert_eq!(parent, read_proc_stat::<i32>(Current, 3).unwrap());\n+        // this next field should always be 0 (which precedes an important bit of info for us!)\n+        assert_eq!(0, read_proc_stat::<i32>(Current, 20).unwrap());\n+    }\n }"
    }
  ],
  "fix_category": NaN,
  "root_cause_category": NaN,
  "root_cause_subcategory": "Deterministic"
}