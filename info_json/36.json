{
  "id": 36,
  "repo": "NavigaTUM",
  "issue_url": "https://github.com/TUM-Dev/NavigaTUM/issues/122",
  "pr_url": "https://github.com/TUM-Dev/NavigaTUM/pull/124",
  "issue_description": "**Describe the bug**\r\nZ10 (and potentially other entries) have an error in the Roomfinder Maps data.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Go to [https://nav.tum.sexy/building/0510](https://nav.tum.sexy/building/0510)\r\n2. Get an empty page because of the error:\r\n    `TypeError: view_data.maps.roomfinder.available[state.map.roomfinder.selected_index] is undefined`\r\n\r\n**Expected behavior**\r\nShould not crash\r\n\r\n**Additional context**\r\nThis is a crash in the frontend (which shouldn't happen), but probably related to an error in the data.\r\n",
  "files_changed": [
    {
      "filename": "data/compile.py",
      "status": "modified",
      "patch": "@@ -69,6 +69,7 @@ def main():\n     \n     print(\"-- 45 Roomfinder maps\")\n     maps.assign_roomfinder_maps(data)\n+    maps.check_roomfinder_maps_default(data)\n     maps.build_roomfinder_maps(data)\n     \n     print(\"-- 46 Overlay maps\")"
    },
    {
      "filename": "data/processors/maps.py",
      "status": "modified",
      "patch": "@@ -18,7 +18,7 @@ def assign_coordinates(data):\n     Assign coordinates to all entries (except root) and make sure they match the data format.\n     \"\"\"\n     # TODO: In the future we might calculate the coordinates from OSM data\n-    \n+\n     # The inference of coordinates in this function for all entries is based on the\n     # coordinates of buildings, so it is necessary, that at least all buildings have\n     # a coordinate.\n@@ -30,15 +30,15 @@ def assign_coordinates(data):\n     if len(buildings_without_coord) > 0:\n         raise RuntimeError(f\"Error: No coordinates known for the following buildings: \"\n               f\"{buildings_without_coord}\")\n-    \n+\n     # All errors are collected first before quitting in the end if any\n     # error occured.\n     error = False\n-    \n+\n     for _id, entry in data.items():\n         if entry[\"type\"] == \"root\":\n             continue\n-        \n+\n         if \"coords\" in entry:\n             # While not observed so far, coordinate values of zero are typical for missing\n             # data so we check this here.\n@@ -54,7 +54,7 @@ def assign_coordinates(data):\n                       f\"{entry['coords']}\")\n                 error = True\n                 continue\n-            \n+\n             # Convert between utm and lat/lon if necessary\n             if \"utm\" not in entry[\"coords\"]:\n                 utm_coord = utm.from_latlon(entry[\"coords\"][\"lat\"], entry[\"coords\"][\"lon\"])\n@@ -70,7 +70,7 @@ def assign_coordinates(data):\n                                              utm_coord[\"zone_number\"], utm_coord[\"zone_letter\"])\n                 entry[\"coords\"][\"lat\"] = latlon_coord[0]\n                 entry[\"coords\"][\"lat\"] = latlon_coord[1]\n-            \n+\n             # If no source is provided, \"navigatum\" is assumed because Roomfinder\n             # provided coordinates will have \"roomfinder\" set.\n             if \"source\" not in entry[\"coords\"]:\n@@ -85,7 +85,7 @@ def assign_coordinates(data):\n                     error = True\n                     continue\n                 building_parent = data[building_parent[0]]\n-                \n+\n                 # Copy probably not required, but this could avoid unwanted side effects\n                 entry[\"coords\"] = copy.deepcopy(building_parent[\"coords\"])\n                 entry[\"coords\"][\"accuracy\"] = \"building\"\n@@ -97,7 +97,7 @@ def assign_coordinates(data):\n                     print(f\"Error: Cannot infer coordinate of '{_id}' because it has no children\")\n                     error = True\n                     continue\n-                \n+\n                 lats, lons = ([], [])\n                 for c in entry[\"children_flat\"]:\n                     if data[c][\"type\"] == \"building\":\n@@ -121,7 +121,7 @@ def assign_coordinates(data):\n                 print(f\"Error: Don't know how to infer coordinate for entry type '{entry['type']}'\")\n                 error = True\n                 continue\n-    \n+\n     if error:\n         raise RuntimeError(\"Aborting due to errors\")\n \n@@ -335,25 +335,25 @@ def _load_maps_list():\n \n def build_roomfinder_maps(data):\n     \"\"\" Generate the map information for the Roomfinder maps. \"\"\"\n-    \n+\n     # Read the Roomfinder and custom maps\n     with open(\"external/maps_roomfinder.json\") as f:\n         maps_list = json.load(f)\n     custom_maps = _load_custom_maps()\n-    \n+\n     # For each map, we calculate the boundaries in UTM beforehand\n     maps = {}\n     for m in maps_list + list(custom_maps.values()):\n         if \"latlonbox\" in m:\n             latlonbox = m[\"latlonbox\"]\n-            \n+\n             latlonbox[\"north_west\"] = (float(latlonbox[\"north\"]), float(latlonbox[\"west\"]))\n             latlonbox[\"south_east\"] = (float(latlonbox[\"south\"]), float(latlonbox[\"east\"]))\n \n             # Roomfinder data is with ints as id, but we use a string based format\n             if isinstance(m[\"id\"], int):\n                 m[\"id\"] = f\"rf{m['id']}\"\n-            \n+\n             maps[m[\"id\"]] = m\n \n     for _id, entry in data.items():\n@@ -417,7 +417,7 @@ def _load_custom_maps():\n     \"\"\" Load the custom maps like Roomfinder maps \"\"\"\n     with open(\"sources/45_custom-maps.yaml\") as f:\n         custom_maps = yaml.safe_load(f.read())\n-        \n+\n     # Convert into the format used by maps_roomfinder.json:\n     maps_out = {}\n     for map_group in custom_maps:\n@@ -451,16 +451,16 @@ def add_overlay_maps(data):\n     \"\"\" Add the overlay maps to all entries where they apply \"\"\"\n     with open(\"sources/46_overlay-maps.yaml\") as f:\n         overlay_maps = yaml.safe_load(f.read())\n-        \n+\n     parent_lut = {m[\"props\"][\"parent\"]: m for m in overlay_maps}\n     parent_ids = set(parent_lut.keys())\n-    \n+\n     for _id, entry in data.items():\n         candidates = parent_ids.intersection(entry[\"parents\"])\n         if len(candidates) > 1:\n             print(f\"Multiple candidates as overlay map for {_id}: {candidates}. \"\n                   f\"Currently this is not supported! Skipping ...\")\n-        elif bool(candidates) ^ (_id in parent_ids):  \n+        elif bool(candidates) ^ (_id in parent_ids):\n             # either a candidate exist or _id is one of the parent ids, but not both\n             overlay = parent_lut[list(candidates)[0] if len(candidates) == 1 else _id]\n             overlay_data = entry.setdefault(\"maps\", {}).setdefault(\"overlays\", {})\n@@ -473,13 +473,27 @@ def add_overlay_maps(data):\n                     \"name\": m[\"desc\"],\n                     \"coordinates\": overlay[\"props\"][\"box\"]\n                 })\n-                \n+\n                 # The 'tumonline' field overwrites which TUMOnline ID floor to match\n                 if f\".{m.get('tumonline', '')}.\" in _id:\n                     overlay_data[\"default\"] = m[\"id\"]\n                 elif f\".{m['floor']}.\" in _id:\n                     overlay_data[\"default\"] = m[\"id\"]\n-            \n+\n             overlay_data.setdefault(\"default\", None)\n-    \n-        \n+\n+\n+def check_roomfinder_maps_default(data):\n+    for _id, entry in data.items():\n+        if \"maps\" in entry and \"roomfinder\" in entry[\"maps\"]:\n+            rf = entry[\"maps\"][\"roomfinder\"]\n+            if not rf.get(\"available\", None):\n+                continue\n+            if \"default\" not in rf:\n+                print(f\"Warning: default map not specified for {_id}\")\n+                continue\n+            default = rf[\"default\"]\n+            if not default:\n+                continue  # no default set\n+            if not any(a[\"id\"] == default for a in rf[\"available\"]):\n+                raise RuntimeError(f\"Error: default map is not in the assigned maps for {_id}\")"
    },
    {
      "filename": "data/processors/roomfinder.py",
      "status": "modified",
      "patch": "@@ -183,15 +183,31 @@ def _get_roomfinder_maps(obj):\n                 \"height\": mapdata[4],\n             })\n \n-    if len(obj[\"default_map\"]) != 0:\n-        # If the default map is the world map, this is usually\n-        # the only map available. As we don't include the world\n-        # map into the available maps, return empty data here\n-        if obj[\"default_map\"][1] == 9:\n-            maps[\"available\"].clear()\n-        else:\n-            maps[\"default\"] = f\"rf{obj['default_map'][1]}\"\n-    \n+    if not obj[\"default_map\"]:\n+        return maps\n+\n+    # If the default map is the world map, this is usually\n+    # the only map available. As we don't include the world\n+    # map into the available maps, return empty data here\n+    if obj[\"default_map\"][1] == 9:\n+        maps[\"available\"].clear()\n+        return maps\n+\n+    maps[\"default\"] = default = f\"rf{obj['default_map'][1]}\"\n+\n+    # sometimes the default map is not in the available maps.\n+    # This is the case for example the building with id \"0510\"\n+    available_map_ids = [m[\"id\"] for m in maps[\"available\"]]\n+    if default and default not in available_map_ids:\n+        mapdata = obj[\"default_map\"]\n+        maps[\"available\"].append(\n+            {\n+                \"id\": f\"rf{mapdata[1]}\",  # Roomfinder data is with ints as id, but we use a string based format\n+                \"scale\": mapdata[0],\n+                \"name\": mapdata[2],\n+                \"width\": mapdata[3],\n+                \"height\": mapdata[4],\n+            })\n     return maps\n         \n "
    }
  ],
  "fix_category": NaN,
  "root_cause_category": NaN,
  "root_cause_subcategory": "!Rust (Python)"
}