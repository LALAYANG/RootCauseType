{
  "id": 4,
  "repo": "fedimint",
  "issue_url": "https://github.com/fedimint/fedimint/issues/3834",
  "pr_url": "https://github.com/fedimint/fedimint/pull/3902",
  "issue_description": "Currently `fedimint-cli spend <amount>` will give us `<amount>` if it has those notes on hand, and give more than we ask for if it doesn't.\r\n\r\nI was just writing a test and this behavior caused my test to be flaky. It would be nice for this reason (and probably in general) to be able to request exact amounts from `fedimint-cli spend`. ",
  "files_changed": [
    {
      "filename": "fedimint-cli/src/client.rs",
      "status": "modified",
      "patch": "@@ -20,7 +20,9 @@ use fedimint_ln_client::{\n     PayType,\n };\n use fedimint_ln_common::contracts::ContractId;\n-use fedimint_mint_client::{MintClientModule, OOBNotes};\n+use fedimint_mint_client::{\n+    MintClientModule, OOBNotes, SelectNotesWithAtleastAmount, SelectNotesWithExactAmount,\n+};\n use fedimint_wallet_client::{WalletClientModule, WithdrawState};\n use futures::StreamExt;\n use itertools::Itertools;\n@@ -29,7 +31,7 @@ use serde::{Deserialize, Serialize};\n use serde_json::json;\n use time::format_description::well_known::iso8601;\n use time::OffsetDateTime;\n-use tracing::{debug, info};\n+use tracing::{debug, info, warn};\n \n use crate::{metadata_from_clap_cli, LnInvoiceResponse};\n \n@@ -58,7 +60,18 @@ pub enum ClientCmd {\n     /// Reissue notes received from a third party to avoid double spends\n     Reissue { oob_notes: OOBNotes },\n     /// Prepare notes to send to a third party as a payment\n-    Spend { amount: Amount },\n+    Spend {\n+        /// The amount of e-cash to spend\n+        amount: Amount,\n+        /// If the exact amount cannot be represented, return e-cash of a higher\n+        /// value instead of failing\n+        #[clap(long)]\n+        allow_overpay: bool,\n+        /// After how many seconds we will try to reclaim the e-cash if it\n+        /// hasn't been redeemed by the recipient. Defaults to one week.\n+        #[clap(long, default_value_t = 60 * 60 * 24 * 7)]\n+        timeout: u64,\n+    },\n     /// Verifies the signatures of e-cash notes, but *not* if they have been\n     /// spent already\n     Validate { oob_notes: OOBNotes },\n@@ -188,11 +201,34 @@ pub async fn handle_command(\n \n             Ok(serde_json::to_value(amount).unwrap())\n         }\n-        ClientCmd::Spend { amount } => {\n-            let (operation, notes) = client\n-                .get_first_module::<MintClientModule>()\n-                .spend_notes(amount, Duration::from_secs(3600), ())\n-                .await?;\n+        ClientCmd::Spend {\n+            amount,\n+            allow_overpay,\n+            timeout,\n+        } => {\n+            warn!(\"The client will try to double-spend these notes after the duration specified by the --timeout option to recover any unclaimed e-cash.\");\n+\n+            let mint_module = client.get_first_module::<MintClientModule>();\n+            let timeout = Duration::from_secs(timeout);\n+            let (operation, notes) = if allow_overpay {\n+                let (operation, notes) = mint_module\n+                    .spend_notes_with_selector(&SelectNotesWithAtleastAmount, amount, timeout, ())\n+                    .await?;\n+\n+                let overspend_amount = notes.total_amount() - amount;\n+                if overspend_amount != Amount::ZERO {\n+                    warn!(\n+                        \"Selected notes {} worth more than requested\",\n+                        overspend_amount\n+                    );\n+                }\n+\n+                (operation, notes)\n+            } else {\n+                mint_module\n+                    .spend_notes_with_selector(&SelectNotesWithExactAmount, amount, timeout, ())\n+                    .await?\n+            };\n             info!(\"Spend e-cash operation: {operation}\");\n \n             Ok(json!({"
    },
    {
      "filename": "modules/fedimint-mint-client/src/lib.rs",
      "status": "modified",
      "patch": "@@ -1428,6 +1428,33 @@ impl<Note: Send> NotesSelector<Note> for SelectNotesWithAtleastAmount {\n     }\n }\n \n+/// Select notes with total amount of *exactly* `request_amount`. If the amount\n+/// cannot be represented with the available denominations an error is returned,\n+/// this **does not** mean that the balance is too low.\n+pub struct SelectNotesWithExactAmount;\n+\n+#[apply(async_trait_maybe_send!)]\n+impl<Note: Send> NotesSelector<Note> for SelectNotesWithExactAmount {\n+    async fn select_notes(\n+        &self,\n+        #[cfg(not(target_family = \"wasm\"))] stream: impl futures::Stream<Item = (Amount, Note)> + Send,\n+        #[cfg(target_family = \"wasm\")] stream: impl futures::Stream<Item = (Amount, Note)>,\n+        requested_amount: Amount,\n+    ) -> anyhow::Result<TieredMulti<Note>> {\n+        let notes = select_notes_from_stream(stream, requested_amount).await?;\n+\n+        if notes.total_amount() != requested_amount {\n+            bail!(\n+                \"Could not select notes with exact amount. Requested amount: {}. Selected amount: {}\",\n+                requested_amount,\n+                notes.total_amount()\n+            );\n+        }\n+\n+        Ok(notes)\n+    }\n+}\n+\n // We are using a greedy algorithm to select notes. We start with the largest\n // then proceed to the lowest tiers/denominations.\n // But there is a catch: we don't know if there are enough notes in the lowest"
    }
  ],
  "fix_category": "Retry",
  "root_cause_category": "Async Wait",
  "root_cause_subcategory": "Retry"
}