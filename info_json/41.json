{
  "id": 41,
  "repo": "foundry",
  "issue_url": "https://github.com/foundry-rs/foundry/issues/49",
  "pr_url": "https://github.com/foundry-rs/foundry/pull/83",
  "issue_description": "We use [svm-rs](https://github.com/roynalnaruto/svm-rs) by @roynalnaruto, which is used for managing the global `solc` binary's version, by installing each version under `~/.svm/4version/solc-$version`. For some reason, when running on CI the installation process seems to be flaky, e.g. below:\r\n\r\n![telegram-cloud-photo-size-2-5366071301866894295-y](https://user-images.githubusercontent.com/17802178/134912737-ae1f3389-ec6a-49b0-b279-aecbf587ae7a.jpg)\r\n\r\nWe should fix that. Maybe there's a bug downstream in `svm-rs` (e.g. there should be some sort of global mutex that says \"hey a solc version is being installed right now, wait for it to unlock before you try running solc\"\r\n\r\nI tried doing that manually with the [lock inside solc/lib.rs](https://github.com/gakonst/dapptools-rs/blob/master/solc/src/lib.rs#L118-L120) but it was not enough apparently.",
  "files_changed": [
    {
      "filename": "dapp/Cargo.toml",
      "status": "modified",
      "patch": "@@ -33,3 +33,4 @@ evm-adapters = { path = \"./../evm-adapters\", features = [\"sputnik\", \"sputnik-hel\n evmodin = { git = \"https://github.com/vorot93/evmodin\", features = [\"util\"] }\n # evm = { version = \"0.30.1\" }\n evm = { git = \"https://github.com/rust-blockchain/evm\" }\n+dapp-solc = { path = \"./../solc\", features = [\"sync\"] }"
    },
    {
      "filename": "solc/Cargo.toml",
      "status": "modified",
      "patch": "@@ -19,3 +19,6 @@ tracing = \"0.1.28\"\n glob = \"0.3.0\"\n tokio = \"1.12.0\"\n rayon = \"1.5.1\"\n+\n+[features]\n+sync = []"
    },
    {
      "filename": "solc/src/lib.rs",
      "status": "modified",
      "patch": "@@ -10,11 +10,11 @@ use std::{\n     time::Instant,\n };\n \n-#[cfg(test)]\n+#[cfg(any(test, feature = \"sync\"))]\n use std::sync::Mutex;\n-#[cfg(test)]\n+#[cfg(any(test, feature = \"sync\"))]\n static LOCK: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));\n-#[cfg(test)]\n+#[cfg(any(test, feature = \"sync\"))]\n use ethers::prelude::Lazy;\n \n /// Supports building contracts\n@@ -23,7 +23,6 @@ pub struct SolcBuilder<'a> {\n     contracts: &'a str,\n     remappings: &'a [String],\n     lib_paths: &'a [String],\n-    versions: Vec<Version>,\n     releases: Vec<Version>,\n }\n \n@@ -33,7 +32,6 @@ impl<'a> SolcBuilder<'a> {\n         remappings: &'a [String],\n         lib_paths: &'a [String],\n     ) -> Result<Self> {\n-        let versions = svm::installed_versions().unwrap_or_default();\n         // Try to download the releases, if it fails default to empty\n         let releases = match tokio::runtime::Runtime::new()?.block_on(svm::all_versions()) {\n             Ok(inner) => inner,\n@@ -42,7 +40,7 @@ impl<'a> SolcBuilder<'a> {\n                 Vec::new()\n             }\n         };\n-        Ok(Self { contracts, remappings, lib_paths, versions, releases })\n+        Ok(Self { contracts, remappings, lib_paths, releases })\n     }\n \n     /// Builds all provided contract files with the specified compiler version.\n@@ -83,7 +81,7 @@ impl<'a> SolcBuilder<'a> {\n \n     /// Builds all contracts with their corresponding compiler versions\n     #[tracing::instrument(skip(self))]\n-    pub fn build_all(&mut self) -> Result<HashMap<String, CompiledContract>> {\n+    pub fn build_all(&self) -> Result<HashMap<String, CompiledContract>> {\n         tracing::info!(\"starting compilation\");\n         let contracts_by_version = self.contract_versions()?;\n         let start = Instant::now();\n@@ -117,7 +115,7 @@ impl<'a> SolcBuilder<'a> {\n     /// to build it, and returns it along with its canonicalized path. If the required\n     /// compiler version is not installed, it also proceeds to install it.\n     #[tracing::instrument(err)]\n-    fn detect_version(&mut self, fname: &Path) -> Result<Option<(Version, String)>> {\n+    fn detect_version(&self, fname: &Path) -> Result<Option<(Version, String)>> {\n         let path = std::fs::canonicalize(fname)?;\n \n         // detects the required solc version\n@@ -128,14 +126,15 @@ impl<'a> SolcBuilder<'a> {\n             .into_string()\n             .map_err(|_| eyre::eyre!(\"invalid path, maybe not utf-8?\"))?;\n \n-        #[cfg(test)]\n+        #[cfg(any(test, feature = \"sync\"))]\n         // take the lock in tests, we use this to enforce that\n         // a test does not run while a compiler version is being installed\n         let _lock = LOCK.lock();\n \n         // load the local / remote versions\n-        let local_versions = Self::find_matching_installation(&mut self.versions, &sol_version);\n-        let remote_versions = Self::find_matching_installation(&mut self.releases, &sol_version);\n+        let versions = svm::installed_versions().unwrap_or_default();\n+        let local_versions = Self::find_matching_installation(&versions, &sol_version);\n+        let remote_versions = Self::find_matching_installation(&self.releases, &sol_version);\n \n         // if there's a better upstream version than the one we have, install it\n         let res = match (local_versions, remote_versions) {\n@@ -158,16 +157,15 @@ impl<'a> SolcBuilder<'a> {\n         Ok(res)\n     }\n \n-    fn install_version(&mut self, version: &Version) {\n+    fn install_version(&self, version: &Version) {\n         println!(\"Installing {}\", version);\n         // Blocking call to install it over RPC.\n         install_blocking(version).expect(\"could not install solc remotely\");\n-        self.versions.push(version.clone());\n         println!(\"Done!\");\n     }\n \n     /// Gets a map of compiler version -> vec[contract paths]\n-    fn contract_versions(&mut self) -> Result<HashMap<String, Vec<String>>> {\n+    fn contract_versions(&self) -> Result<HashMap<String, Vec<String>>> {\n         // Group contracts in the nones with the same version pragma\n         let files = glob::glob(self.contracts)?;\n         // tracing::trace!(\"Compiling files under {}\", self.contracts);\n@@ -222,11 +220,9 @@ impl<'a> SolcBuilder<'a> {\n \n     /// Find a matching local installation for the specified required version\n     fn find_matching_installation(\n-        versions: &mut [Version],\n+        versions: &[Version],\n         required_version: &VersionReq,\n     ) -> Option<Version> {\n-        // sort through them\n-        versions.sort();\n         // iterate in reverse to find the last match\n         versions.iter().rev().find(|version| required_version.matches(version)).cloned()\n     }\n@@ -263,6 +259,9 @@ mod tests {\n \n     #[test]\n     fn test_find_installed_version_path() {\n+        // this test does not take the lock by default, so we need to manually\n+        // add it here.\n+        let _lock = LOCK.lock();\n         let ver = \"0.8.6\";\n         let version = Version::from_str(ver).unwrap();\n         if !svm::installed_versions().unwrap().contains(&version) {\n@@ -283,26 +282,26 @@ mod tests {\n \n     #[test]\n     fn test_find_latest_matching_installation() {\n-        let mut versions = [\"0.4.24\", \"0.5.1\", \"0.5.2\"]\n+        let versions = [\"0.4.24\", \"0.5.1\", \"0.5.2\"]\n             .iter()\n             .map(|version| Version::from_str(version).unwrap())\n             .collect::<Vec<_>>();\n \n         let required = VersionReq::from_str(\">=0.4.24\").unwrap();\n \n-        let got = SolcBuilder::find_matching_installation(&mut versions, &required).unwrap();\n+        let got = SolcBuilder::find_matching_installation(&versions, &required).unwrap();\n         assert_eq!(got, versions[2]);\n     }\n \n     #[test]\n     fn test_no_matching_installation() {\n-        let mut versions = [\"0.4.24\", \"0.5.1\", \"0.5.2\"]\n+        let versions = [\"0.4.24\", \"0.5.1\", \"0.5.2\"]\n             .iter()\n             .map(|version| Version::from_str(version).unwrap())\n             .collect::<Vec<_>>();\n \n         let required = VersionReq::from_str(\">=0.6.0\").unwrap();\n-        let got = SolcBuilder::find_matching_installation(&mut versions, &required);\n+        let got = SolcBuilder::find_matching_installation(&versions, &required);\n         assert!(got.is_none());\n     }\n \n@@ -371,7 +370,7 @@ mod tests {\n     fn test_detect_version() {\n         let dir = mkdir();\n \n-        let mut builder = SolcBuilder::new(\"\", &[], &[]).unwrap();\n+        let builder = SolcBuilder::new(\"\", &[], &[]).unwrap();\n         for (pragma, expected) in [\n             // pinned\n             (\"=0.4.14\", \"0.4.14\"),\n@@ -422,7 +421,7 @@ mod tests {\n \n         let dir_str = dir.clone().into_os_string().into_string().unwrap();\n         let glob = format!(\"{}/**/*.sol\", dir_str);\n-        let mut builder = SolcBuilder::new(&glob, &[], &[]).unwrap();\n+        let builder = SolcBuilder::new(&glob, &[], &[]).unwrap();\n \n         let versions = builder.contract_versions().unwrap();\n         assert_eq!(versions[\"0.4.14\"].len(), 2);\n@@ -442,7 +441,7 @@ mod tests {\n     #[test]\n     fn test_build_all_versions() {\n         let path = get_glob(\"testdata/test-contract-versions\");\n-        let mut builder = SolcBuilder::new(&path, &[], &[]).unwrap();\n+        let builder = SolcBuilder::new(&path, &[], &[]).unwrap();\n         let res = builder.build_all().unwrap();\n         // Contracts A to F\n         assert_eq!(res.keys().collect::<Vec<_>>().len(), 5);\n@@ -460,7 +459,7 @@ mod tests {\n             .into_string()\n             .unwrap();\n         let libs = vec![lib];\n-        let mut builder = SolcBuilder::new(&path, &remappings, &libs).unwrap();\n+        let builder = SolcBuilder::new(&path, &remappings, &libs).unwrap();\n         let res = builder.build_all().unwrap();\n         // Foo & Bar\n         assert_eq!(res.keys().collect::<Vec<_>>().len(), 2);\n@@ -481,7 +480,7 @@ mod tests {\n             canonicalized_path(\"testdata/test-contract-libs/lib1\"),\n             canonicalized_path(\"testdata/test-contract-libs/lib2\"),\n         ];\n-        let mut builder = SolcBuilder::new(&path, &[], &libs).unwrap();\n+        let builder = SolcBuilder::new(&path, &[], &libs).unwrap();\n         let res = builder.build_all().unwrap();\n         // Foo & Bar\n         assert_eq!(res.keys().collect::<Vec<_>>().len(), 3);"
    }
  ],
  "fix_category": "Mutex",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Lock"
}