{
  "id": 45,
  "repo": "deltachat-core-rust",
  "issue_url": "https://github.com/deltachat/deltachat-core-rust/issues/5201",
  "pr_url": "https://github.com/deltachat/deltachat-core-rust/pull/5669",
  "issue_description": "Attached is a log from CI:\r\n[flaky-test.txt](https://github.com/deltachat/deltachat-core-rust/files/14000065/flaky-test.txt)\r\n\r\n\r\nMaybe similar issue to #5191 but better understand what exactly happened.",
  "files_changed": [
    {
      "filename": "src/download.rs",
      "status": "modified",
      "patch": "@@ -184,7 +184,7 @@ impl Session {\n             bail!(\"Attempt to fetch UID 0\");\n         }\n \n-        self.select_folder(context, folder).await?;\n+        self.select_with_uidvalidity(context, folder).await?;\n \n         // we are connected, and the folder is selected\n         info!(context, \"Downloading message {}/{} fully...\", folder, uid);"
    },
    {
      "filename": "src/imap.rs",
      "status": "modified",
      "patch": "@@ -543,15 +543,16 @@ impl Imap {\n             return Ok(false);\n         }\n \n-        let new_emails = session\n+        session\n             .select_with_uidvalidity(context, folder)\n             .await\n             .with_context(|| format!(\"Failed to select folder {folder:?}\"))?;\n \n-        if !new_emails && !fetch_existing_msgs {\n+        if !session.new_mail && !fetch_existing_msgs {\n             info!(context, \"No new emails in folder {folder:?}.\");\n             return Ok(false);\n         }\n+        session.new_mail = false;\n \n         let uid_validity = get_uidvalidity(context, folder).await?;\n         let old_uid_next = get_uid_next(context, folder).await?;\n@@ -838,7 +839,7 @@ impl Session {\n         // Collect pairs of UID and Message-ID.\n         let mut msgs = BTreeMap::new();\n \n-        self.select_folder(context, folder).await?;\n+        self.select_with_uidvalidity(context, folder).await?;\n \n         let mut list = self\n             .uid_fetch(\"1:*\", RFC724MID_UID)\n@@ -1039,7 +1040,7 @@ impl Session {\n             // MOVE/DELETE operations. This does not result in multiple SELECT commands\n             // being sent because `select_folder()` does nothing if the folder is already\n             // selected.\n-            self.select_folder(context, folder).await?;\n+            self.select_with_uidvalidity(context, folder).await?;\n \n             // Empty target folder name means messages should be deleted.\n             if target.is_empty() {\n@@ -1087,7 +1088,7 @@ impl Session {\n             .await?;\n \n         for (folder, rowid_set, uid_set) in UidGrouper::from(rows) {\n-            self.select_folder(context, &folder)\n+            self.select_with_uidvalidity(context, &folder)\n                 .await\n                 .context(\"failed to select folder\")?;\n \n@@ -1131,7 +1132,7 @@ impl Session {\n             return Ok(());\n         }\n \n-        self.select_folder(context, folder)\n+        self.select_with_uidvalidity(context, folder)\n             .await\n             .context(\"failed to select folder\")?;\n "
    },
    {
      "filename": "src/imap/idle.rs",
      "status": "modified",
      "patch": "@@ -29,9 +29,13 @@ impl Session {\n     ) -> Result<Self> {\n         use futures::future::FutureExt;\n \n-        self.select_folder(context, folder).await?;\n+        self.select_with_uidvalidity(context, folder).await?;\n \n         if self.server_sent_unsolicited_exists(context)? {\n+            self.new_mail = true;\n+        }\n+\n+        if self.new_mail {\n             return Ok(self);\n         }\n \n@@ -92,6 +96,9 @@ impl Session {\n         session.as_mut().set_read_timeout(Some(IMAP_TIMEOUT));\n         self.inner = session;\n \n+        // Fetch mail once we exit IDLE.\n+        self.new_mail = true;\n+\n         Ok(self)\n     }\n }"
    },
    {
      "filename": "src/imap/select_folder.rs",
      "status": "modified",
      "patch": "@@ -10,12 +10,6 @@ type Result<T> = std::result::Result<T, Error>;\n \n #[derive(Debug, thiserror::Error)]\n pub enum Error {\n-    #[error(\"IMAP Connection Lost or no connection established\")]\n-    ConnectionLost,\n-\n-    #[error(\"IMAP Folder name invalid: {0}\")]\n-    BadFolderName(String),\n-\n     #[error(\"Got a NO response when trying to select {0}, usually this means that it doesn't exist: {1}\")]\n     NoFolder(String, String),\n \n@@ -33,7 +27,8 @@ impl ImapSession {\n     /// Issues a CLOSE command if selected folder needs expunge,\n     /// i.e. if Delta Chat marked a message there as deleted previously.\n     ///\n-    /// CLOSE is considerably faster than an EXPUNGE, see\n+    /// CLOSE is considerably faster than an EXPUNGE\n+    /// because no EXPUNGE responses are sent, see\n     /// <https://tools.ietf.org/html/rfc3501#section-6.4.2>\n     pub(super) async fn maybe_close_folder(&mut self, context: &Context) -> anyhow::Result<()> {\n         if let Some(folder) = &self.selected_folder {\n@@ -44,6 +39,7 @@ impl ImapSession {\n                 info!(context, \"close/expunge succeeded\");\n                 self.selected_folder = None;\n                 self.selected_folder_needs_expunge = false;\n+                self.new_mail = false;\n             }\n         }\n         Ok(())\n@@ -52,11 +48,7 @@ impl ImapSession {\n     /// Selects a folder, possibly updating uid_validity and, if needed,\n     /// expunging the folder to remove delete-marked messages.\n     /// Returns whether a new folder was selected.\n-    pub(crate) async fn select_folder(\n-        &mut self,\n-        context: &Context,\n-        folder: &str,\n-    ) -> Result<NewlySelected> {\n+    async fn select_folder(&mut self, context: &Context, folder: &str) -> Result<NewlySelected> {\n         // if there is a new folder and the new folder is equal to the selected one, there's nothing to do.\n         // if there is _no_ new folder, we continue as we might want to expunge below.\n         if let Some(selected_folder) = &self.selected_folder {\n@@ -85,10 +77,6 @@ impl ImapSession {\n                 self.selected_mailbox = Some(mailbox);\n                 Ok(NewlySelected::Yes)\n             }\n-            Err(async_imap::error::Error::ConnectionLost) => Err(Error::ConnectionLost),\n-            Err(async_imap::error::Error::Validate(_)) => {\n-                Err(Error::BadFolderName(folder.to_string()))\n-            }\n             Err(async_imap::error::Error::No(response)) => {\n                 Err(Error::NoFolder(folder.to_string(), response))\n             }\n@@ -128,13 +116,14 @@ impl ImapSession {\n     /// When selecting a folder for the first time, sets the uid_next to the current\n     /// mailbox.uid_next so that no old emails are fetched.\n     ///\n-    /// Returns Result<new_emails> (i.e. whether new emails arrived),\n-    /// if in doubt, returns new_emails=true so emails are fetched.\n+    /// Updates `self.new_mail` if folder was previously unselected\n+    /// and new mails are detected after selecting,\n+    /// i.e. UIDNEXT advanced while the folder was closed.\n     pub(crate) async fn select_with_uidvalidity(\n         &mut self,\n         context: &Context,\n         folder: &str,\n-    ) -> Result<bool> {\n+    ) -> Result<()> {\n         let newly_selected = self\n             .select_or_create_folder(context, folder)\n             .await\n@@ -191,28 +180,26 @@ impl ImapSession {\n         mailbox.uid_next = new_uid_next;\n \n         if new_uid_validity == old_uid_validity {\n-            let new_emails = if newly_selected == NewlySelected::No {\n-                // The folder was not newly selected i.e. no SELECT command was run. This means that mailbox.uid_next\n-                // was not updated and may contain an incorrect value. So, just return true so that\n-                // the caller tries to fetch new messages (we could of course run a SELECT command now, but trying to fetch\n-                // new messages is only one command, just as a SELECT command)\n-                true\n-            } else if let Some(new_uid_next) = new_uid_next {\n-                if new_uid_next < old_uid_next {\n-                    warn!(\n-                        context,\n-                        \"The server illegally decreased the uid_next of folder {folder:?} from {old_uid_next} to {new_uid_next} without changing validity ({new_uid_validity}), resyncing UIDs...\",\n-                    );\n-                    set_uid_next(context, folder, new_uid_next).await?;\n-                    context.schedule_resync().await?;\n+            if newly_selected == NewlySelected::Yes {\n+                if let Some(new_uid_next) = new_uid_next {\n+                    if new_uid_next < old_uid_next {\n+                        warn!(\n+                            context,\n+                            \"The server illegally decreased the uid_next of folder {folder:?} from {old_uid_next} to {new_uid_next} without changing validity ({new_uid_validity}), resyncing UIDs...\",\n+                        );\n+                        set_uid_next(context, folder, new_uid_next).await?;\n+                        context.schedule_resync().await?;\n+                    }\n+\n+                    // If UIDNEXT changed, there are new emails.\n+                    self.new_mail |= new_uid_next != old_uid_next;\n+                } else {\n+                    warn!(context, \"Folder {folder} was just selected but we failed to determine UIDNEXT, assume that it has new mail.\");\n+                    self.new_mail = true;\n                 }\n-                new_uid_next != old_uid_next // If UIDNEXT changed, there are new emails\n-            } else {\n-                // We have no UIDNEXT and if in doubt, return true.\n-                true\n-            };\n+            }\n \n-            return Ok(new_emails);\n+            return Ok(());\n         }\n \n         // UIDVALIDITY is modified, reset highest seen MODSEQ.\n@@ -223,6 +210,7 @@ impl ImapSession {\n         let new_uid_next = new_uid_next.unwrap_or_default();\n         set_uid_next(context, folder, new_uid_next).await?;\n         set_uidvalidity(context, folder, new_uid_validity).await?;\n+        self.new_mail = true;\n \n         // Collect garbage entries in `imap` table.\n         context\n@@ -245,7 +233,7 @@ impl ImapSession {\n             old_uid_next,\n             old_uid_validity,\n         );\n-        Ok(false)\n+        Ok(())\n     }\n }\n "
    },
    {
      "filename": "src/imap/session.rs",
      "status": "modified",
      "patch": "@@ -40,6 +40,11 @@ pub(crate) struct Session {\n     pub selected_mailbox: Option<Mailbox>,\n \n     pub selected_folder_needs_expunge: bool,\n+\n+    /// True if currently selected folder has new messages.\n+    ///\n+    /// Should be false if no folder is currently selected.\n+    pub new_mail: bool,\n }\n \n impl Deref for Session {\n@@ -67,6 +72,7 @@ impl Session {\n             selected_folder: None,\n             selected_mailbox: None,\n             selected_folder_needs_expunge: false,\n+            new_mail: false,\n         }\n     }\n "
    }
  ],
  "fix_category": "Retry request",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Retry"
}