{
  "id": 48,
  "repo": "fuel-core",
  "issue_url": "https://github.com/FuelLabs/fuel-core/issues/2107",
  "pr_url": "https://github.com/FuelLabs/fuel-core/pull/2113",
  "issue_description": "It appears that after version 0.32, executing the GraphQL query `estimateGasPrice(10)` immediately after starting fuel-core will often throw the error below, making tests very flaky on [`fuels-ts`](https://github.com/FuelLabs/fuels-ts).\r\n\r\n```console\r\nFailed to estimate gas price for block, algorithm not yet set: 10\r\n```\r\n\r\n\r\n\r\nQuoting suspicions below:\r\n\r\n> @MitchTurner: I believe this is a race condition where the graphql services task is started before the gas price service is fully initialized. Each is run in a separate thread and we don't have any extra synchronization to make sure one is started before the other.\r\n\r\n> @Voxelot: hmm we need the graphql service up and running early otherwise the service may look unhealthy if other tasks take a while to initialize. We could split the graphql request handling from the health endpoint so they could be initialized at different times? (edited) \r\n",
  "files_changed": [
    {
      "filename": "CHANGELOG.md",
      "status": "modified",
      "patch": "@@ -6,6 +6,9 @@ and this project adheres to [Semantic Versioning](http://semver.org/).\n \n ## [Unreleased]\n \n+### Changed\n+- [2113](https://github.com/FuelLabs/fuel-core/pull/2113): Modify the way the gas price service and shared algo is initialized to have some default value based on best guess instead of `None`, and initialize service before graphql.\n+\n ## [Version 0.34.0]\n \n ### Added"
    },
    {
      "filename": "crates/fuel-core/src/service/adapters/fuel_gas_price_provider.rs",
      "status": "modified",
      "patch": "@@ -6,7 +6,6 @@ use fuel_core_gas_price_service::{\n use fuel_core_producer::block_producer::gas_price::GasPriceProvider as ProducerGasPriceProvider;\n use fuel_core_txpool::{\n     ports::GasPriceProvider as TxPoolGasPriceProvider,\n-    Error as TxPoolError,\n     Result as TxPoolResult,\n };\n use fuel_core_types::fuel_types::BlockHeight;\n@@ -54,7 +53,7 @@ impl<A> FuelGasPriceProvider<A>\n where\n     A: GasPriceAlgorithm + Send + Sync,\n {\n-    async fn next_gas_price(&self) -> Option<u64> {\n+    async fn next_gas_price(&self) -> u64 {\n         self.algorithm.next_gas_price().await\n     }\n }\n@@ -65,9 +64,7 @@ where\n     A: GasPriceAlgorithm + Send + Sync,\n {\n     async fn next_gas_price(&self) -> anyhow::Result<u64> {\n-        self.next_gas_price()\n-            .await\n-            .ok_or(anyhow::anyhow!(\"No gas price available\"))\n+        Ok(self.next_gas_price().await)\n     }\n }\n \n@@ -77,11 +74,7 @@ where\n     A: GasPriceAlgorithm + Send + Sync,\n {\n     async fn next_gas_price(&self) -> TxPoolResult<u64> {\n-        self.next_gas_price()\n-            .await\n-            .ok_or(TxPoolError::GasPriceNotFound(\n-                \"Gas price not set yet\".to_string(),\n-            ))\n+        Ok(self.next_gas_price().await)\n     }\n }\n \n@@ -91,6 +84,6 @@ where\n     A: GasPriceAlgorithm + Send + Sync,\n {\n     async fn worst_case_gas_price(&self, height: BlockHeight) -> Option<u64> {\n-        self.algorithm.worst_case_gas_price(height).await\n+        Some(self.algorithm.worst_case_gas_price(height).await)\n     }\n }"
    },
    {
      "filename": "crates/fuel-core/src/service/adapters/fuel_gas_price_provider/tests/producer_gas_price_tests.rs",
      "status": "modified",
      "patch": "@@ -13,7 +13,7 @@ async fn gas_price__if_requested_block_height_is_latest_return_gas_price() {\n \n     // when\n     let expected_price = algo.next_gas_price();\n-    let actual_price = gas_price_provider.next_gas_price().await.unwrap();\n+    let actual_price = gas_price_provider.next_gas_price().await;\n \n     // then\n     assert_eq!(expected_price, actual_price);"
    },
    {
      "filename": "crates/fuel-core/src/service/adapters/fuel_gas_price_provider/tests/tx_pool_gas_price_tests.rs",
      "status": "modified",
      "patch": "@@ -13,7 +13,7 @@ async fn gas_price__if_requested_block_height_is_latest_return_gas_price() {\n \n     // when\n     let expected_price = algo.next_gas_price();\n-    let actual_price = gas_price_provider.next_gas_price().await.unwrap();\n+    let actual_price = gas_price_provider.next_gas_price().await;\n \n     // then\n     assert_eq!(expected_price, actual_price);"
    },
    {
      "filename": "crates/fuel-core/src/service/sub_services.rs",
      "status": "modified",
      "patch": "@@ -332,11 +332,9 @@ pub fn init_sub_services(\n     #[allow(unused_mut)]\n     // `FuelService` starts and shutdowns all sub-services in the `services` order\n     let mut services: SubServices = vec![\n-        // GraphQL should be shutdown first, so let's start it first.\n-        Box::new(graph_ql),\n+        Box::new(gas_price_service),\n         Box::new(txpool),\n         Box::new(consensus_parameters_provider_service),\n-        Box::new(gas_price_service),\n     ];\n \n     if let Some(poa) = poa {\n@@ -356,6 +354,7 @@ pub fn init_sub_services(\n         }\n     }\n \n+    services.push(Box::new(graph_ql));\n     services.push(Box::new(graphql_worker));\n \n     Ok((services, shared))"
    },
    {
      "filename": "crates/fuel-core/src/service/sub_services/algorithm_updater.rs",
      "status": "modified",
      "patch": "@@ -16,6 +16,7 @@ use crate::{\n use fuel_core_gas_price_service::{\n     fuel_gas_price_updater::{\n         fuel_core_storage_adapter::{\n+            storage::GasPriceMetadata,\n             FuelL2BlockSource,\n             GasPriceSettingsProvider,\n         },\n@@ -88,7 +89,13 @@ impl InitializeTask {\n         gas_price_db: Database<GasPriceDatabase, RegularStage<GasPriceDatabase>>,\n         on_chain_db: Database<OnChain, RegularStage<OnChain>>,\n     ) -> anyhow::Result<Self> {\n-        let shared_algo = SharedGasPriceAlgo::new();\n+        let latest_block_height = on_chain_db\n+            .latest_height()\n+            .unwrap_or(genesis_block_height)\n+            .into();\n+        let default_metadata = get_default_metadata(&config, latest_block_height);\n+        let algo = get_best_algo(&gas_price_db, default_metadata)?;\n+        let shared_algo = SharedGasPriceAlgo::new_with_algorithm(algo);\n         let task = Self {\n             config,\n             genesis_block_height,\n@@ -102,6 +109,34 @@ impl InitializeTask {\n     }\n }\n \n+fn get_default_metadata(config: &Config, latest_block_height: u32) -> UpdaterMetadata {\n+    UpdaterMetadata::V0(V0Metadata {\n+        new_exec_price: config.starting_gas_price.max(config.min_gas_price),\n+        min_exec_gas_price: config.min_gas_price,\n+        exec_gas_price_change_percent: config.gas_price_change_percent,\n+        l2_block_height: latest_block_height,\n+        l2_block_fullness_threshold_percent: config.gas_price_threshold_percent,\n+    })\n+}\n+\n+fn get_best_algo(\n+    gas_price_db: &Database<GasPriceDatabase, RegularStage<GasPriceDatabase>>,\n+    default_metadata: UpdaterMetadata,\n+) -> anyhow::Result<Algorithm> {\n+    let best_metadata: UpdaterMetadata =\n+        if let Some(height) = gas_price_db.latest_height() {\n+            gas_price_db\n+                .storage::<GasPriceMetadata>()\n+                .get(&height)?\n+                .map(|m| m.into_owned())\n+                .unwrap_or(default_metadata)\n+        } else {\n+            default_metadata\n+        };\n+    let updater: AlgorithmUpdater = best_metadata.into();\n+    let algo = updater.algorithm();\n+    Ok(algo)\n+}\n #[async_trait::async_trait]\n impl RunnableService for InitializeTask {\n     const NAME: &'static str = \"GasPriceUpdater\";\n@@ -124,7 +159,7 @@ impl RunnableService for InitializeTask {\n             .unwrap_or(self.genesis_block_height);\n \n         let updater = get_synced_gas_price_updater(\n-            &self.config,\n+            self.config,\n             self.genesis_block_height,\n             self.settings,\n             self.gas_price_db,\n@@ -138,7 +173,7 @@ impl RunnableService for InitializeTask {\n }\n \n pub fn get_synced_gas_price_updater(\n-    config: &Config,\n+    config: Config,\n     genesis_block_height: BlockHeight,\n     settings: ConsensusParametersProvider,\n     mut gas_price_db: Database<GasPriceDatabase, RegularStage<GasPriceDatabase>>,\n@@ -158,14 +193,7 @@ pub fn get_synced_gas_price_updater(\n         first_run = true;\n         latest_block_height\n     };\n-\n-    let first_metadata = UpdaterMetadata::V0(V0Metadata {\n-        new_exec_price: config.starting_gas_price.max(config.min_gas_price),\n-        min_exec_gas_price: config.min_gas_price,\n-        exec_gas_price_change_percent: config.gas_price_change_percent,\n-        l2_block_height: latest_block_height,\n-        l2_block_fullness_threshold_percent: config.gas_price_threshold_percent,\n-    });\n+    let default_metadata = get_default_metadata(&config, latest_block_height);\n \n     if metadata_height > latest_block_height {\n         revert_gas_price_db_to_height(&mut gas_price_db, latest_block_height.into())?;\n@@ -183,7 +211,7 @@ pub fn get_synced_gas_price_updater(\n \n     if BlockHeight::from(latest_block_height) == genesis_block_height || first_run {\n         let updater = FuelGasPriceUpdater::new(\n-            first_metadata.into(),\n+            default_metadata.into(),\n             l2_block_source,\n             metadata_storage,\n         );"
    },
    {
      "filename": "crates/services/gas_price_service/src/lib.rs",
      "status": "modified",
      "patch": "@@ -79,7 +79,7 @@ where\n }\n \n #[derive(Debug, Default)]\n-pub struct SharedGasPriceAlgo<A>(Arc<RwLock<Option<A>>>);\n+pub struct SharedGasPriceAlgo<A>(Arc<RwLock<A>>);\n \n impl<A> Clone for SharedGasPriceAlgo<A> {\n     fn clone(&self) -> Self {\n@@ -91,34 +91,26 @@ impl<A> SharedGasPriceAlgo<A>\n where\n     A: Send + Sync,\n {\n-    pub fn new() -> Self {\n-        Self(Arc::new(RwLock::new(None)))\n-    }\n-\n     pub fn new_with_algorithm(algorithm: A) -> Self {\n-        Self(Arc::new(RwLock::new(Some(algorithm))))\n+        Self(Arc::new(RwLock::new(algorithm)))\n     }\n \n     pub async fn update(&mut self, new_algo: A) {\n         let mut write_lock = self.0.write().await;\n-        *write_lock = Some(new_algo);\n+        *write_lock = new_algo;\n     }\n }\n \n impl<A> SharedGasPriceAlgo<A>\n where\n     A: GasPriceAlgorithm + Send + Sync,\n {\n-    pub async fn next_gas_price(&self) -> Option<u64> {\n-        self.0.read().await.as_ref().map(|a| a.next_gas_price())\n+    pub async fn next_gas_price(&self) -> u64 {\n+        self.0.read().await.next_gas_price()\n     }\n \n-    pub async fn worst_case_gas_price(&self, block_height: BlockHeight) -> Option<u64> {\n-        self.0\n-            .read()\n-            .await\n-            .as_ref()\n-            .map(|a| a.worst_case_gas_price(block_height))\n+    pub async fn worst_case_gas_price(&self, block_height: BlockHeight) -> u64 {\n+        self.0.read().await.worst_case_gas_price(block_height)\n     }\n }\n \n@@ -236,16 +228,19 @@ mod tests {\n     async fn run__updates_gas_price() {\n         // given\n         let (price_sender, price_receiver) = mpsc::channel(1);\n+        let start_algo = TestAlgorithm { price: 50 };\n+        let expected_price = 100;\n         let updater = TestAlgorithmUpdater {\n-            start: TestAlgorithm { price: 0 },\n+            start: TestAlgorithm {\n+                price: expected_price,\n+            },\n             price_source: price_receiver,\n         };\n-        let shared_algo = SharedGasPriceAlgo::new();\n+        let shared_algo = SharedGasPriceAlgo::new_with_algorithm(start_algo);\n         let service = GasPriceService::new(0.into(), updater, shared_algo).await;\n         let watcher = StateWatcher::started();\n         let read_algo = service.next_block_algorithm();\n         let task = service.into_task(&watcher, ()).await.unwrap();\n-        let expected_price = 100;\n         let service = ServiceRunner::new(task);\n         service.start().unwrap();\n \n@@ -254,7 +249,7 @@ mod tests {\n         tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n \n         // then\n-        let actual_price = read_algo.next_gas_price().await.unwrap();\n+        let actual_price = read_algo.next_gas_price().await;\n         assert_eq!(expected_price, actual_price);\n     }\n }"
    }
  ],
  "fix_category": "Reorder initialization",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Reorder initialization"
}