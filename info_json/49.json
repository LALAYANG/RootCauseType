{
  "id": 49,
  "repo": "casper-node",
  "issue_url": "https://github.com/casper-network/casper-node/issues/3293",
  "pr_url": "https://github.com/casper-network/casper-node/pull/3294",
  "issue_description": "This seems to be flaky, and unrelated to the PR:\nhttps://drone-auto-casper-network.casperlabs.io/casper-network/casper-node/6206/2/4",
  "files_changed": [
    {
      "filename": "execution_engine/src/storage/trie_store/operations/mod.rs",
      "status": "modified",
      "patch": "@@ -9,7 +9,7 @@ use std::{\n     time::Instant,\n };\n \n-use tracing::{error, trace};\n+use tracing::{error, trace, warn};\n \n use casper_hashing::Digest;\n use casper_types::bytesrepr::{self, FromBytes, ToBytes};\n@@ -96,11 +96,12 @@ where\n                             current = next;\n                         }\n                         None => {\n-                            panic!(\n+                            warn!(\n                                 \"No trie value at key: {:?} (reading from key: {:?})\",\n                                 pointer.hash(),\n                                 key\n                             );\n+                            return Ok(ReadResult::NotFound);\n                         }\n                     },\n                     None => {\n@@ -117,11 +118,12 @@ where\n                             current = next;\n                         }\n                         None => {\n-                            panic!(\n+                            warn!(\n                                 \"No trie value at key: {:?} (reading from key: {:?})\",\n                                 pointer.hash(),\n                                 key\n                             );\n+                            return Ok(ReadResult::NotFound);\n                         }\n                     }\n                 } else {\n@@ -192,11 +194,12 @@ where\n                 let next = match store.get(txn, pointer.hash())? {\n                     Some(next) => next,\n                     None => {\n-                        panic!(\n-                            \"No trie value at key: {:?} (reading from key: {:?})\",\n+                        warn!(\n+                            \"No trie value at key: {:?} (reading from path: {:?})\",\n                             pointer.hash(),\n-                            key\n+                            path\n                         );\n+                        return Ok(ReadResult::NotFound);\n                     }\n                 };\n                 depth += 1;\n@@ -216,11 +219,12 @@ where\n                 let next = match store.get(txn, pointer.hash())? {\n                     Some(next) => next,\n                     None => {\n-                        panic!(\n-                            \"No trie value at key: {:?} (reading from key: {:?})\",\n+                        warn!(\n+                            \"No trie value at key: {:?} (reading from path: {:?})\",\n                             pointer.hash(),\n-                            key\n+                            path\n                         );\n+                        return Ok(ReadResult::NotFound);\n                     }\n                 };\n                 depth += affix.len();\n@@ -410,7 +414,7 @@ fn scan<K, V, T, S, E>(\n     store: &S,\n     key_bytes: &[u8],\n     root: &Trie<K, V>,\n-) -> Result<TrieScan<K, V>, E>\n+) -> Result<Option<TrieScan<K, V>>, E>\n where\n     K: ToBytes + FromBytes + Clone,\n     V: ToBytes + FromBytes + Clone,\n@@ -428,7 +432,7 @@ where\n     loop {\n         match current {\n             leaf @ Trie::Leaf { .. } => {\n-                return Ok(TrieScan::new(leaf, acc));\n+                return Ok(Some(TrieScan::new(leaf, acc)));\n             }\n             Trie::Node { pointer_block } => {\n                 let index = {\n@@ -443,7 +447,7 @@ where\n                 let pointer = match maybe_pointer {\n                     Some(pointer) => pointer,\n                     None => {\n-                        return Ok(TrieScan::new(Trie::Node { pointer_block }, acc));\n+                        return Ok(Some(TrieScan::new(Trie::Node { pointer_block }, acc)));\n                     }\n                 };\n                 match store.get(txn, pointer.hash())? {\n@@ -453,18 +457,19 @@ where\n                         acc.push((index, Trie::Node { pointer_block }))\n                     }\n                     None => {\n-                        panic!(\n+                        warn!(\n                             \"No trie value at key: {:?} (reading from path: {:?})\",\n                             pointer.hash(),\n                             path\n                         );\n+                        return Ok(None);\n                     }\n                 }\n             }\n             Trie::Extension { affix, pointer } => {\n                 let sub_path = &path[depth..depth + affix.len()];\n                 if sub_path != affix.as_slice() {\n-                    return Ok(TrieScan::new(Trie::Extension { affix, pointer }, acc));\n+                    return Ok(Some(TrieScan::new(Trie::Extension { affix, pointer }, acc)));\n                 }\n                 match store.get(txn, pointer.hash())? {\n                     Some(next) => {\n@@ -477,11 +482,12 @@ where\n                         acc.push((index, Trie::Extension { affix, pointer }))\n                     }\n                     None => {\n-                        panic!(\n+                        warn!(\n                             \"No trie value at key: {:?} (reading from path: {:?})\",\n                             pointer.hash(),\n                             path\n                         );\n+                        return Ok(None);\n                     }\n                 }\n             }\n@@ -519,7 +525,10 @@ where\n \n     let key_bytes = key_to_delete.to_bytes()?;\n     let TrieScan { tip, mut parents } =\n-        scan::<_, _, _, _, E>(correlation_id, txn, store, &key_bytes, &root_trie)?;\n+        match scan::<_, _, _, _, E>(correlation_id, txn, store, &key_bytes, &root_trie)? {\n+            Some(trie_scan) => trie_scan,\n+            None => return Ok(DeleteResult::DoesNotExist),\n+        };\n \n     // Check that tip is a leaf\n     match tip {\n@@ -967,7 +976,13 @@ where\n             };\n             let path: Vec<u8> = key.to_bytes()?;\n             let TrieScan { tip, parents } =\n-                scan::<K, V, T, S, E>(correlation_id, txn, store, &path, &current_root)?;\n+                match scan::<K, V, T, S, E>(correlation_id, txn, store, &path, &current_root)? {\n+                    Some(trie_scan) => trie_scan,\n+                    // If we are scanning the trie and it's not complete under the given root, then\n+                    // in the context of a write we must consider this root to \"not exist\".\n+                    // This can happen when a trie is being sync'd or is incomplete.\n+                    None => return Ok(WriteResult::RootNotFound),\n+                };\n             let new_elements: Vec<(Digest, Trie<K, V>)> = match tip {\n                 // If the \"tip\" is the same as the new leaf, then the leaf\n                 // is already in the Trie."
    },
    {
      "filename": "execution_engine/src/storage/trie_store/operations/tests/scan.rs",
      "status": "modified",
      "patch": "@@ -32,7 +32,8 @@ where\n         store,\n         key,\n         &root,\n-    )?;\n+    )?\n+    .expect(\"trie scan returned no leaf\");\n \n     for (index, parent) in parents.into_iter().rev() {\n         let expected_tip_hash = {"
    }
  ],
  "fix_category": "Support failure case",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Robustness"
}