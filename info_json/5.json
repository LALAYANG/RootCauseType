{
  "id": 5,
  "repo": "ethersync",
  "issue_url": "https://github.com/ethersync/ethersync/issues/36",
  "pr_url": "https://github.com/ethersync/ethersync/pull/35",
  "issue_description": "The fuzzer causes some ungraceful shutdown of the tokio tasks, which makes CI fail in a flaky way.",
  "files_changed": [
    {
      "filename": "daemon/src/daemon.rs",
      "status": "modified",
      "patch": "@@ -301,19 +301,18 @@ impl DocumentActor {\n                 self.maybe_process_crdt_file_deltas_in_ot(file_deltas).await;\n                 self.process_cursor_states(cursor_states).await;\n \n-                response_tx\n-                    .send(peer_state)\n-                    .expect(\"Failed to send peer state in response to ReceiveSyncMessage\");\n+                if response_tx.send(peer_state).is_err() {\n+                    warn!(\"Failed to send peer state in response to ReceiveSyncMessage.\");\n+                }\n             }\n             DocMessage::GenerateSyncMessage {\n                 state: mut peer_state,\n                 response_tx,\n             } => {\n                 let message = self.crdt_doc.generate_sync_message(&mut peer_state);\n-                let val = response_tx.send((peer_state, message));\n \n-                if let Err(val) = val {\n-                    warn!(\"Failed to send peer state and sync message in response to GenerateSyncMessage: {val:?}\");\n+                if response_tx.send((peer_state, message)).is_err() {\n+                    warn!(\"Failed to send peer state and sync message in response to GenerateSyncMessage.\");\n                 }\n             }\n             DocMessage::NewEditorConnection(editor_handle) => {\n@@ -489,9 +488,7 @@ impl DocumentActor {\n                 uri: format!(\"file://{}\", self.absolute_path_for_file_path(&file_path)),\n                 ranges,\n             };\n-            for handle in &mut self.editor_clients.values_mut() {\n-                handle.send(message.clone()).await;\n-            }\n+            self.send_to_editor_clients(message).await;\n         }\n     }\n \n@@ -500,9 +497,22 @@ impl DocumentActor {\n             uri: format!(\"file://{}\", self.absolute_path_for_file_path(file_path)),\n             delta: rev_delta,\n         };\n+        self.send_to_editor_clients(message).await;\n+    }\n \n-        for handle in &mut self.editor_clients.values_mut() {\n-            handle.send(message.clone()).await;\n+    async fn send_to_editor_clients(&mut self, message: EditorProtocolMessageToEditor) {\n+        let mut to_remove = Vec::new();\n+        for (id, handle) in &mut self.editor_clients.iter_mut() {\n+            if handle.send(message.clone()).await.is_err() {\n+                // Remove this client.\n+                to_remove.push(*id);\n+            }\n+        }\n+        for id in to_remove {\n+            // The destructor of EditorHandle will shut down the actors when\n+            // we remove it from the HashMap.\n+            info!(\"Removing EditorHandle from client list.\");\n+            self.editor_clients.remove(&id);\n         }\n     }\n \n@@ -585,7 +595,7 @@ impl DocumentActor {\n         while let Some(message) = self.doc_message_rx.recv().await {\n             self.handle_message(message).await;\n         }\n-        panic!(\"Channel towards document task has been closed\");\n+        debug!(\"Channel towards document handle has been closed (probably shutting down)\");\n     }\n }\n "
    },
    {
      "filename": "daemon/src/editor.rs",
      "status": "modified",
      "patch": "@@ -1,4 +1,5 @@\n /// This module is all about daemon to editor communication.\n+use std::io;\n use tokio::{\n     io::{AsyncBufReadExt, AsyncWriteExt, BufReader, ReadHalf, WriteHalf},\n     net::UnixStream,\n@@ -22,6 +23,7 @@ pub async fn spawn_editor_connection(stream: UnixStream, document_handle: Docume\n \n pub struct EditorHandle {\n     editor_message_tx: EditorMessageSender,\n+    shutdown_token: CancellationToken,\n }\n \n impl EditorHandle {\n@@ -35,18 +37,32 @@ impl EditorHandle {\n         let mut reader = SocketReadActor::new(stream_read, shutdown_token.clone(), document_handle);\n         tokio::spawn(async move { reader.run().await });\n \n-        let mut writer = SocketWriteActor::new(stream_write, socket_message_rx, shutdown_token);\n+        let mut writer =\n+            SocketWriteActor::new(stream_write, socket_message_rx, shutdown_token.clone());\n         tokio::spawn(async move { writer.run().await });\n         Self {\n             editor_message_tx: socket_message_tx,\n+            shutdown_token,\n         }\n     }\n \n-    pub async fn send(&self, message: EditorProtocolMessageToEditor) {\n-        self.editor_message_tx\n-            .send(message)\n-            .await\n-            .expect(\"Failed to send to editor.\");\n+    pub async fn send(&self, message: EditorProtocolMessageToEditor) -> Result<(), io::Error> {\n+        // Can fail during shutdown or editor disconnect, when Actors already have been killed/closed\n+        if self.editor_message_tx.send(message).await.is_err() {\n+            Err(io::Error::new(\n+                io::ErrorKind::BrokenPipe,\n+                \"Can't keep up or dead\",\n+            ))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for EditorHandle {\n+    fn drop(&mut self) {\n+        debug!(\"Editor Handle dropped, shutting down socket actors\");\n+        self.shutdown_token.cancel();\n     }\n }\n \n@@ -134,7 +150,7 @@ impl SocketWriteActor {\n         loop {\n             tokio::select! {\n                 () = self.shutdown_token.cancelled() => {\n-                    debug!(\"Shutting down JSON-RPC sender (due to socket disconnet)\");\n+                    debug!(\"Shutting down JSON-RPC sender (due to socket disconnect)\");\n                     break;\n                 }\n                 editor_message_maybe = self.editor_message_receiver.recv() => match editor_message_maybe {"
    }
  ],
  "fix_category": "Cleanup",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Channels"
}