{
  "id": 50,
  "repo": "miden-client",
  "issue_url": "https://github.com/0xPolygonMiden/miden-client/issues/391",
  "pr_url": "https://github.com/0xPolygonMiden/miden-client/pull/410",
  "issue_description": "Looks like [`test_swap_offchain()` is flaky right now](https://github.com/0xPolygonMiden/miden-client/actions/runs/9591340149/job/26448074126#step:8:352). We should review and fix it.",
  "files_changed": [
    {
      "filename": "CHANGELOG.md",
      "status": "modified",
      "patch": "@@ -2,6 +2,7 @@\n \n ## v0.5.0 (TBD)\n \n+* Fix flaky integration tests (#410).\n * Add conversions for `NoteRecordDetails` (#392).\n \n ## v0.4.0 (2024-07-05)"
    },
    {
      "filename": "tests/integration/main.rs",
      "status": "modified",
      "patch": "@@ -841,16 +841,22 @@ async fn test_update_ignored_tag() {\n         .unwrap();\n \n     // Ignored notes are only retrieved for \"Ignored\" or \"All\" filters\n-    assert_eq!(client_2.get_input_notes(NoteFilter::All).unwrap().len(), 1);\n-    assert_eq!(client_2.get_input_notes(NoteFilter::Ignored).unwrap().len(), 1);\n-    assert_eq!(client_2.get_input_notes(NoteFilter::Expected).unwrap().len(), 0);\n+    let all_notes = client_2.get_input_notes(NoteFilter::All).unwrap();\n+    let ignored_notes = client_2.get_input_notes(NoteFilter::Ignored).unwrap();\n+    let expected_notes = client_2.get_input_notes(NoteFilter::Expected).unwrap();\n+    assert!(all_notes.iter().any(|candidate_note| candidate_note.id() == note.id()));\n+    assert!(ignored_notes.iter().any(|candidate_note| candidate_note.id() == note.id()));\n+    assert!(expected_notes.iter().all(|candidate_note| candidate_note.id() != note.id()));\n \n     client_2.add_note_tag(untracked_tag).unwrap();\n \n     // After adding tag, the note stops being ignored\n-    assert_eq!(client_2.get_input_notes(NoteFilter::All).unwrap().len(), 1);\n-    assert_eq!(client_2.get_input_notes(NoteFilter::Ignored).unwrap().len(), 0);\n-    assert_eq!(client_2.get_input_notes(NoteFilter::Expected).unwrap().len(), 1);\n+    let all_notes = client_2.get_input_notes(NoteFilter::All).unwrap();\n+    let ignored_notes = client_2.get_input_notes(NoteFilter::Ignored).unwrap();\n+    let expected_notes = client_2.get_input_notes(NoteFilter::Expected).unwrap();\n+    assert!(all_notes.iter().any(|candidate_note| candidate_note.id() == note.id()));\n+    assert!(ignored_notes.iter().all(|candidate_note| candidate_note.id() != note.id()));\n+    assert!(expected_notes.iter().any(|candidate_note| candidate_note.id() == note.id()));\n }\n \n #[tokio::test]"
    },
    {
      "filename": "tests/integration/swap_transactions_tests.rs",
      "status": "modified",
      "patch": "@@ -6,7 +6,7 @@ use miden_client::{\n use miden_objects::{\n     accounts::{AccountId, AccountStorageType},\n     assets::{Asset, FungibleAsset, TokenSymbol},\n-    notes::{NoteExecutionHint, NoteFile, NoteTag, NoteType},\n+    notes::{NoteExecutionHint, NoteFile, NoteId, NoteTag, NoteType},\n };\n \n use super::common::*;\n@@ -66,17 +66,17 @@ async fn test_swap_fully_onchain() {\n \n     // mint 1000 BTC for accountA\n     println!(\"minting 1000 btc for account A\");\n-    mint(\n+    let account_a_mint_note_id = mint(\n         &mut client_with_faucets,\n         account_a.id(),\n         btc_faucet_account.id(),\n         NoteType::Public,\n         BTC_MINT_AMOUNT,\n     )\n     .await;\n-    println!(\"minting 1000 eth for account B\");\n     // mint 1000 ETH for accountB\n-    mint(\n+    println!(\"minting 1000 eth for account B\");\n+    let account_b_mint_note_id = mint(\n         &mut client_with_faucets,\n         account_b.id(),\n         eth_faucet_account.id(),\n@@ -87,23 +87,27 @@ async fn test_swap_fully_onchain() {\n \n     // Sync and consume note for accountA\n     client1.sync_state().await.unwrap();\n-    let client_1_notes = client1.get_input_notes(miden_client::store::NoteFilter::All).unwrap();\n-    assert_eq!(client_1_notes.len(), 1);\n+    let client_1_consumable_notes = client1.get_consumable_notes(Some(account_a.id())).unwrap();\n+    assert!(client_1_consumable_notes\n+        .iter()\n+        .any(|(note, _)| note.id() == account_a_mint_note_id));\n \n     println!(\"Consuming mint note on first client...\");\n     let tx_template =\n-        TransactionTemplate::ConsumeNotes(account_a.id(), vec![client_1_notes[0].id()]);\n+        TransactionTemplate::ConsumeNotes(account_a.id(), vec![account_a_mint_note_id]);\n     let tx_request = client1.build_transaction_request(tx_template).unwrap();\n     execute_tx_and_sync(&mut client1, tx_request).await;\n \n     // Sync and consume note for accountB\n     client2.sync_state().await.unwrap();\n-    let client_2_notes = client2.get_input_notes(miden_client::store::NoteFilter::All).unwrap();\n-    assert_eq!(client_2_notes.len(), 1);\n+    let client_2_consumable_notes = client2.get_consumable_notes(Some(account_b.id())).unwrap();\n+    assert!(client_2_consumable_notes\n+        .iter()\n+        .any(|(note, _)| note.id() == account_b_mint_note_id));\n \n     println!(\"Consuming mint note on second client...\");\n     let tx_template =\n-        TransactionTemplate::ConsumeNotes(account_b.id(), vec![client_2_notes[0].id()]);\n+        TransactionTemplate::ConsumeNotes(account_b.id(), vec![account_b_mint_note_id]);\n     let tx_request = client2.build_transaction_request(tx_template).unwrap();\n     execute_tx_and_sync(&mut client2, tx_request).await;\n \n@@ -272,7 +276,7 @@ async fn test_swap_offchain() {\n \n     // mint 1000 BTC for accountA\n     println!(\"minting 1000 btc for account A\");\n-    mint(\n+    let account_a_mint_note_id = mint(\n         &mut client_with_faucets,\n         account_a.id(),\n         btc_faucet_account.id(),\n@@ -282,7 +286,7 @@ async fn test_swap_offchain() {\n     .await;\n     // mint 1000 ETH for accountB\n     println!(\"minting 1000 eth for account B\");\n-    mint(\n+    let account_b_mint_note_id = mint(\n         &mut client_with_faucets,\n         account_b.id(),\n         eth_faucet_account.id(),\n@@ -293,23 +297,27 @@ async fn test_swap_offchain() {\n \n     // Sync and consume note for accountA\n     client1.sync_state().await.unwrap();\n-    let client_1_notes = client1.get_input_notes(miden_client::store::NoteFilter::All).unwrap();\n-    assert_eq!(client_1_notes.len(), 1);\n+    let client_1_consumable_notes = client1.get_consumable_notes(Some(account_a.id())).unwrap();\n+    assert!(client_1_consumable_notes\n+        .iter()\n+        .any(|(note, _)| note.id() == account_a_mint_note_id));\n \n     println!(\"Consuming mint note on first client...\");\n     let tx_template =\n-        TransactionTemplate::ConsumeNotes(account_a.id(), vec![client_1_notes[0].id()]);\n+        TransactionTemplate::ConsumeNotes(account_a.id(), vec![account_a_mint_note_id]);\n     let tx_request = client1.build_transaction_request(tx_template).unwrap();\n     execute_tx_and_sync(&mut client1, tx_request).await;\n \n     // Sync and consume note for accountB\n     client2.sync_state().await.unwrap();\n-    let client_2_notes = client2.get_input_notes(miden_client::store::NoteFilter::All).unwrap();\n-    assert_eq!(client_2_notes.len(), 1);\n+    let client_2_consumable_notes = client2.get_consumable_notes(Some(account_b.id())).unwrap();\n+    assert!(client_2_consumable_notes\n+        .iter()\n+        .any(|(note, _)| note.id() == account_b_mint_note_id));\n \n     println!(\"Consuming mint note on second client...\");\n     let tx_template =\n-        TransactionTemplate::ConsumeNotes(account_b.id(), vec![client_2_notes[0].id()]);\n+        TransactionTemplate::ConsumeNotes(account_b.id(), vec![account_b_mint_note_id]);\n     let tx_request = client2.build_transaction_request(tx_template).unwrap();\n     execute_tx_and_sync(&mut client2, tx_request).await;\n \n@@ -468,8 +476,7 @@ fn build_swap_tag(\n     .unwrap()\n }\n \n-/// Mints a note from faucet_account_id for basic_account_id, waits for inclusion and returns it\n-/// with 1000 units of the corresponding fungible asset\n+/// Mints a note from faucet_account_id for basic_account_id with 1000 units of the corresponding fungible asset, waits for inclusion and returns the note id.\n ///\n /// `basic_account_id` does not need to be tracked by the client, but `faucet_account_id` does\n async fn mint(\n@@ -478,7 +485,7 @@ async fn mint(\n     faucet_account_id: AccountId,\n     note_type: NoteType,\n     mint_amount: u64,\n-) {\n+) -> NoteId {\n     // Create a Mint Tx for 1000 units of our fungible asset\n     let fungible_asset = FungibleAsset::new(faucet_account_id, mint_amount).unwrap();\n     let tx_template =\n@@ -487,4 +494,6 @@ async fn mint(\n     println!(\"Minting Asset\");\n     let tx_request = client.build_transaction_request(tx_template).unwrap();\n     execute_tx_and_sync(client, tx_request.clone()).await;\n+\n+    tx_request.expected_output_notes()[0].id()\n }"
    }
  ],
  "fix_category": "More generalized test",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Shared state"
}