{
  "id": 52,
  "repo": "subxt",
  "issue_url": "https://github.com/paritytech/subxt/issues/1240",
  "pr_url": "https://github.com/paritytech/subxt/pull/1305",
  "issue_description": "Detected by: https://github.com/paritytech/subxt/actions/runs/6745755385/job/18338194383\r\n\r\n\r\n```bash\r\n--- STDERR:              integration-tests full_client::frame::staking::tx_bond ---\r\nthread 'full_client::frame::staking::tx_bond' panicked at testing/integration-tests/src/full_client/frame/staking.rs:216:5:\r\nassertion failed: `Err(Transaction(Invalid(\"Invalid transaction: Transaction is outdated\")))` does not match `Err(Error::Runtime(DispatchError::Module(err)))`\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n```",
  "files_changed": [
    {
      "filename": "subxt/src/backend/unstable/mod.rs",
      "status": "modified",
      "patch": "@@ -436,10 +436,26 @@ impl<T: Config + Send + Sync + 'static> Backend<T> for UnstableBackend<T> {\n         &self,\n         extrinsic: &[u8],\n     ) -> Result<StreamOfResults<TransactionStatus<T::Hash>>, Error> {\n-        // First, subscribe to all new block hashes\n-        let mut new_blocks = self.follow_handle.subscribe().events().filter_map(|ev| {\n+        // We care about new and finalized block hashes.\n+        enum SeenBlock<Ref> {\n+            New(Ref),\n+            Finalized(Vec<Ref>),\n+        }\n+        enum SeenBlockMarker {\n+            New,\n+            Finalized,\n+        }\n+\n+        // First, subscribe to all new and finalized block refs.\n+        // - we subscribe to new refs so that when we see `BestChainBlockIncluded`, we\n+        //   can try to return a block ref for the best block.\n+        // - we subscribe to finalized refs so that when we see `Finalized`, we can\n+        //   guarantee that when we return here, the finalized block we report has been\n+        //   reported from chainHead_follow already.\n+        let mut seen_blocks_sub = self.follow_handle.subscribe().events().filter_map(|ev| {\n             std::future::ready(match ev {\n-                FollowEvent::NewBlock(ev) => Some(ev.block_hash),\n+                FollowEvent::NewBlock(ev) => Some(SeenBlock::New(ev.block_hash)),\n+                FollowEvent::Finalized(ev) => Some(SeenBlock::Finalized(ev.finalized_block_hashes)),\n                 _ => None,\n             })\n         });\n@@ -453,8 +469,9 @@ impl<T: Config + Send + Sync + 'static> Backend<T> for UnstableBackend<T> {\n         let mut seen_blocks = HashMap::new();\n         let mut done = false;\n \n-        // If we see the finalized event, we start waiting until we find a block that\n-        // matches, so we can guarantee to return a pinned block hash.\n+        // If we see the finalized event, we start waiting until we find a finalized block that\n+        // matches, so we can guarantee to return a pinned block hash and be properly in sync\n+        // with chainHead_follow.\n         let mut finalized_hash: Option<T::Hash> = None;\n \n         // Now we can attempt to associate tx events with pinned blocks.\n@@ -465,25 +482,42 @@ impl<T: Config + Send + Sync + 'static> Backend<T> for UnstableBackend<T> {\n                     return Poll::Ready(None);\n                 }\n \n-                // Save any pinned blocks. Keep doing this until no more, so that we always have the most uptodate\n-                // pinned blocks when we are looking at our tx events.\n-                if let Poll::Ready(Some(block_ref)) = new_blocks.poll_next_unpin(cx) {\n-                    seen_blocks.insert(block_ref.hash(), block_ref);\n+                // Make a note of new or finalized blocks that have come in since we started the TX.\n+                if let Poll::Ready(Some(seen_block)) = seen_blocks_sub.poll_next_unpin(cx) {\n+                    match seen_block {\n+                        SeenBlock::New(block_ref) => {\n+                            // Optimization: once we have a `finalized_hash`, we only care about finalized\n+                            // block refs now and can avoid bothering to save new blocks.\n+                            if finalized_hash.is_none() {\n+                                seen_blocks\n+                                    .insert(block_ref.hash(), (SeenBlockMarker::New, block_ref));\n+                            }\n+                        }\n+                        SeenBlock::Finalized(block_refs) => {\n+                            for block_ref in block_refs {\n+                                seen_blocks.insert(\n+                                    block_ref.hash(),\n+                                    (SeenBlockMarker::Finalized, block_ref),\n+                                );\n+                            }\n+                        }\n+                    }\n                     continue;\n                 }\n \n                 // If we have a finalized hash, we are done looking for tx events and we are just waiting\n                 // for a pinned block with a matching hash (which must appear eventually given it's finalized).\n                 if let Some(hash) = &finalized_hash {\n-                    if let Some(block_ref) = seen_blocks.remove(hash) {\n+                    if let Some((SeenBlockMarker::Finalized, block_ref)) = seen_blocks.remove(hash)\n+                    {\n                         // Found it! Hand back the event with a pinned block. We're done.\n                         done = true;\n                         let ev = TransactionStatus::InFinalizedBlock {\n                             hash: block_ref.into(),\n                         };\n                         return Poll::Ready(Some(Ok(ev)));\n                     } else {\n-                        // Keep waiting for more new blocks until we find it (get rid of any other block refs\n+                        // Keep waiting for more finalized blocks until we find it (get rid of any other block refs\n                         // now, since none of them were what we were looking for anyway).\n                         seen_blocks.clear();\n                         continue;\n@@ -517,8 +551,8 @@ impl<T: Config + Send + Sync + 'static> Backend<T> for UnstableBackend<T> {\n                         // block that likely isn't accessible. We have no guarantee that a best\n                         // block on the node a tx was sent to will ever be known about on the\n                         // chainHead_follow subscription.\n-                        let block_ref = match seen_blocks.get(&block.hash).cloned() {\n-                            Some(block_ref) => block_ref.into(),\n+                        let block_ref = match seen_blocks.get(&block.hash) {\n+                            Some((_, block_ref)) => block_ref.clone().into(),\n                             None => BlockRef::from_hash(block.hash),\n                         };\n                         TransactionStatus::InBestBlock { hash: block_ref }"
    }
  ],
  "fix_category": "Wait",
  "root_cause_category": "Async Wait",
  "root_cause_subcategory": "Wait"
}