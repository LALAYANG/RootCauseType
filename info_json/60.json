{
  "id": 60,
  "repo": "libxmtp",
  "issue_url": "https://github.com/xmtp/libxmtp/issues/772",
  "pr_url": "https://github.com/xmtp/libxmtp/pull/835",
  "issue_description": "### Is your feature request related to a problem?\n\nhttps://github.com/xmtp/libxmtp/blob/75ee4aeb869d66340226893ff98d8daf188166ff/bindings_ffi/src/mls.rs#L1044\r\n\r\nTest is flaking b/c the streamed messages are arriving too slow to one end of the `stream`. Calls to `tokio::sleep` are supposed to give time for messages to arrive but depending on architecture/system speed this varies. \r\n\r\n\n\n### Describe the solution to the problem\n\nIt would be great to use `async-barrier` for these tests in order to guarantee sync points and avoid flakiness\n\n### Describe the uses cases for the feature\n\n_No response_\n\n### Additional details\n\n_No response_",
  "files_changed": [
    {
      "filename": "bindings_ffi/Cargo.lock",
      "status": "modified",
      "patch": "@@ -2582,6 +2582,15 @@ version = \"0.4.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"90ed8c1e510134f979dbc4f070f87d4313098b704861a105fe34231c70a3901c\"\n \n+[[package]]\n+name = \"matchers\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558\"\n+dependencies = [\n+ \"regex-automata 0.1.10\",\n+]\n+\n [[package]]\n name = \"matchit\"\n version = \"0.7.3\"\n@@ -2706,6 +2715,16 @@ dependencies = [\n  \"minimal-lexical\",\n ]\n \n+[[package]]\n+name = \"nu-ansi-term\"\n+version = \"0.46.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84\"\n+dependencies = [\n+ \"overload\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"num-bigint\"\n version = \"0.4.4\"\n@@ -2970,6 +2989,12 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"04744f49eae99ab78e0d5c0b603ab218f515ea8cfe5a456d7629ad883a3b6e7d\"\n \n+[[package]]\n+name = \"overload\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39\"\n+\n [[package]]\n name = \"p256\"\n version = \"0.13.2\"\n@@ -3707,10 +3732,19 @@ checksum = \"c117dbdfde9c8308975b6a18d71f3f385c89461f7b3fb054288ecf2a2058ba4c\"\n dependencies = [\n  \"aho-corasick\",\n  \"memchr\",\n- \"regex-automata\",\n+ \"regex-automata 0.4.4\",\n  \"regex-syntax 0.8.2\",\n ]\n \n+[[package]]\n+name = \"regex-automata\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132\"\n+dependencies = [\n+ \"regex-syntax 0.6.29\",\n+]\n+\n [[package]]\n name = \"regex-automata\"\n version = \"0.4.4\"\n@@ -3722,6 +3756,12 @@ dependencies = [\n  \"regex-syntax 0.8.2\",\n ]\n \n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.6.29\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1\"\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.7.5\"\n@@ -4349,6 +4389,15 @@ dependencies = [\n  \"keccak\",\n ]\n \n+[[package]]\n+name = \"sharded-slab\"\n+version = \"0.1.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n [[package]]\n name = \"signal-hook-registry\"\n version = \"1.4.1\"\n@@ -4673,6 +4722,16 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"thread_local\"\n+version = \"1.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8b9ef9bad013ada3808854ceac7b46812a6465ba368859a37e2100283d2d719c\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"once_cell\",\n+]\n+\n [[package]]\n name = \"time\"\n version = \"0.3.31\"\n@@ -5051,6 +5110,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c06d3da6113f116aaee68e4d601191614c9053067f9ab7f6edbcb161237daa54\"\n dependencies = [\n  \"once_cell\",\n+ \"valuable\",\n ]\n \n [[package]]\n@@ -5063,6 +5123,35 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"tracing-log\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3\"\n+dependencies = [\n+ \"log\",\n+ \"once_cell\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-subscriber\"\n+version = \"0.3.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ad0f048c97dbd9faa9b7df56362b8ebcaa52adb06b498c050d2f4e32f90a7a8b\"\n+dependencies = [\n+ \"matchers\",\n+ \"nu-ansi-term\",\n+ \"once_cell\",\n+ \"regex\",\n+ \"sharded-slab\",\n+ \"smallvec\",\n+ \"thread_local\",\n+ \"tracing\",\n+ \"tracing-core\",\n+ \"tracing-log\",\n+]\n+\n [[package]]\n name = \"try-lock\"\n version = \"0.2.5\"\n@@ -5359,6 +5448,12 @@ dependencies = [\n  \"rand\",\n ]\n \n+[[package]]\n+name = \"valuable\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d\"\n+\n [[package]]\n name = \"vcpkg\"\n version = \"0.2.15\"\n@@ -5903,6 +5998,7 @@ dependencies = [\n  \"thiserror\",\n  \"tls_codec 0.4.0\",\n  \"tokio\",\n+ \"tokio-stream\",\n  \"toml 0.8.8\",\n  \"tracing\",\n  \"xmtp_cryptography\",\n@@ -5970,6 +6066,7 @@ dependencies = [\n  \"thread-id\",\n  \"tokio\",\n  \"tokio-test\",\n+ \"tracing-subscriber\",\n  \"uniffi\",\n  \"uniffi_macros\",\n  \"uuid 1.9.1\","
    },
    {
      "filename": "bindings_ffi/Cargo.toml",
      "status": "modified",
      "patch": "@@ -23,6 +23,7 @@ xmtp_proto = { path = \"../xmtp_proto\", features = [\"proto_full\", \"grpc\"] }\n xmtp_user_preferences = { path = \"../xmtp_user_preferences\" }\n xmtp_v2 = { path = \"../xmtp_v2\" }\n \n+tracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n # NOTE: A regression in openssl-sys exists where libatomic is dynamically linked \n # for i686-linux-android targets. https://github.com/sfackler/rust-openssl/issues/2163\n #\n@@ -46,6 +47,7 @@ tempfile = \"3.5.0\"\n tokio = { version = \"1.28.1\", features = [\"full\"] }\n tokio-test = \"0.4\"\n uniffi = { version = \"0.27.2\", features = [\"bindgen-tests\"] }\n+tracing-subscriber = \"0.3\"\n uuid = { version = \"1.9\", features = [\"v4\", \"fast-rng\" ] }\n \n # NOTE: The release profile reduces bundle size from 230M to 41M - may have performance impliciations"
    },
    {
      "filename": "bindings_ffi/src/mls.rs",
      "status": "modified",
      "patch": "@@ -4,11 +4,8 @@ use crate::logger::FfiLogger;\n use crate::GenericError;\n use std::collections::HashMap;\n use std::convert::TryInto;\n-use std::sync::{\n-    atomic::{AtomicBool, Ordering},\n-    Arc, Mutex,\n-};\n-use tokio::sync::oneshot::Sender;\n+use std::sync::Arc;\n+use tokio::{sync::Mutex, task::AbortHandle};\n use xmtp_api_grpc::grpc_api_helper::Client as TonicApiClient;\n use xmtp_id::{\n     associations::{\n@@ -32,6 +29,7 @@ use xmtp_mls::{\n     api::ApiClientWrapper,\n     builder::ClientBuilder,\n     client::Client as MlsClient,\n+    client::ClientError,\n     groups::{\n         group_metadata::{ConversationType, GroupMetadata},\n         group_permissions::GroupMutablePermissions,\n@@ -44,6 +42,7 @@ use xmtp_mls::{\n         group_message::{DeliveryStatus, GroupMessageKind, StoredGroupMessage},\n         EncryptedMessageStore, EncryptionKey, StorageOption,\n     },\n+    subscriptions::StreamHandle,\n };\n \n pub type RustXmtpClient = MlsClient<TonicApiClient>;\n@@ -175,8 +174,7 @@ pub fn generate_inbox_id(account_address: String, nonce: u64) -> String {\n \n #[derive(uniffi::Object)]\n pub struct FfiSignatureRequest {\n-    // Using `tokio::sync::Mutex` bc rust MutexGuard cannot be sent between threads.\n-    inner: Arc<tokio::sync::Mutex<SignatureRequest>>,\n+    inner: Arc<Mutex<SignatureRequest>>,\n }\n \n #[uniffi::export(async_runtime = \"tokio\")]\n@@ -305,7 +303,7 @@ impl FfiXmtpClient {\n             .signature_request()\n             .map(|request| {\n                 Arc::new(FfiSignatureRequest {\n-                    inner: Arc::new(tokio::sync::Mutex::new(request)),\n+                    inner: Arc::new(Mutex::new(request)),\n                 })\n             })\n     }\n@@ -616,43 +614,30 @@ impl FfiConversations {\n         Ok(convo_list)\n     }\n \n-    pub async fn stream(\n-        &self,\n-        callback: Box<dyn FfiConversationCallback>,\n-    ) -> Result<Arc<FfiStreamCloser>, GenericError> {\n+    pub fn stream(&self, callback: Box<dyn FfiConversationCallback>) -> FfiStreamCloser {\n         let client = self.inner_client.clone();\n-        let stream_closer = RustXmtpClient::stream_conversations_with_callback(\n-            client.clone(),\n-            move |convo| {\n+        let handle =\n+            RustXmtpClient::stream_conversations_with_callback(client.clone(), move |convo| {\n                 callback.on_conversation(Arc::new(FfiGroup {\n                     inner_client: client.clone(),\n                     group_id: convo.group_id,\n                     created_at_ns: convo.created_at_ns,\n                 }))\n-            },\n-            || {}, // on_close_callback\n-        )?;\n+            });\n \n-        Ok(Arc::new(FfiStreamCloser {\n-            close_fn: stream_closer.close_fn,\n-            is_closed_atomic: stream_closer.is_closed_atomic,\n-        }))\n+        FfiStreamCloser::new(handle)\n     }\n \n-    pub async fn stream_all_messages(\n+    pub fn stream_all_messages(\n         &self,\n         message_callback: Box<dyn FfiMessageCallback>,\n-    ) -> Result<Arc<FfiStreamCloser>, GenericError> {\n-        let stream_closer = RustXmtpClient::stream_all_messages_with_callback(\n+    ) -> FfiStreamCloser {\n+        let handle = RustXmtpClient::stream_all_messages_with_callback(\n             self.inner_client.clone(),\n             move |message| message_callback.on_message(message.into()),\n-        )\n-        .await?;\n+        );\n \n-        Ok(Arc::new(FfiStreamCloser {\n-            close_fn: stream_closer.close_fn,\n-            is_closed_atomic: stream_closer.is_closed_atomic,\n-        }))\n+        FfiStreamCloser::new(handle)\n     }\n }\n \n@@ -1131,22 +1116,16 @@ impl FfiGroup {\n         Ok(())\n     }\n \n-    pub async fn stream(\n-        &self,\n-        message_callback: Box<dyn FfiMessageCallback>,\n-    ) -> Result<Arc<FfiStreamCloser>, GenericError> {\n+    pub fn stream(&self, message_callback: Box<dyn FfiMessageCallback>) -> FfiStreamCloser {\n         let inner_client = Arc::clone(&self.inner_client);\n-        let stream_closer = MlsGroup::stream_with_callback(\n+        let handle = MlsGroup::stream_with_callback(\n             inner_client,\n             self.group_id.clone(),\n             self.created_at_ns,\n             move |message| message_callback.on_message(message.into()),\n-        )?;\n+        );\n \n-        Ok(Arc::new(FfiStreamCloser {\n-            close_fn: stream_closer.close_fn,\n-            is_closed_atomic: stream_closer.is_closed_atomic,\n-        }))\n+        FfiStreamCloser::new(handle)\n     }\n \n     pub fn created_at_ns(&self) -> i64 {\n@@ -1261,27 +1240,67 @@ impl From<StoredGroupMessage> for FfiMessage {\n     }\n }\n \n-#[derive(uniffi::Object)]\n+#[derive(uniffi::Object, Clone, Debug)]\n pub struct FfiStreamCloser {\n-    close_fn: Arc<Mutex<Option<Sender<()>>>>,\n-    is_closed_atomic: Arc<AtomicBool>,\n+    #[allow(clippy::type_complexity)]\n+    stream_handle: Arc<Mutex<Option<StreamHandle<Result<(), ClientError>>>>>,\n+    // for convenience, does not require locking mutex.\n+    abort_handle: Arc<AbortHandle>,\n+}\n+\n+impl FfiStreamCloser {\n+    pub fn new(stream_handle: StreamHandle<Result<(), ClientError>>) -> Self {\n+        Self {\n+            abort_handle: Arc::new(stream_handle.handle.abort_handle()),\n+            stream_handle: Arc::new(Mutex::new(Some(stream_handle))),\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    pub async fn wait_for_ready(&self) {\n+        let mut handle = self.stream_handle.lock().await;\n+        if let Some(ref mut h) = &mut *handle {\n+            h.wait_for_ready().await;\n+        }\n+    }\n }\n \n #[uniffi::export]\n impl FfiStreamCloser {\n+    /// Signal the stream to end\n+    /// Does not wait for the stream to end.\n     pub fn end(&self) {\n-        match self.close_fn.lock() {\n-            Ok(mut close_fn_option) => {\n-                let _ = close_fn_option.take().map(|close_fn| close_fn.send(()));\n-            }\n-            _ => {\n-                log::warn!(\"close_fn already closed\");\n+        self.abort_handle.abort();\n+    }\n+\n+    /// End the stream and asyncronously wait for it to shutdown\n+    pub async fn end_and_wait(&self) -> Result<(), GenericError> {\n+        if self.abort_handle.is_finished() {\n+            return Ok(());\n+        }\n+\n+        let mut stream_handle = self.stream_handle.lock().await;\n+        let stream_handle = stream_handle.take();\n+        if let Some(h) = stream_handle {\n+            h.handle.abort();\n+            match h.handle.await {\n+                Err(e) if !e.is_cancelled() => Err(GenericError::Generic {\n+                    err: format!(\"subscription event loop join error {}\", e),\n+                }),\n+                Err(e) if e.is_cancelled() => Ok(()),\n+                Ok(t) => t.map_err(|e| GenericError::Generic { err: e.to_string() }),\n+                Err(e) => Err(GenericError::Generic {\n+                    err: format!(\"error joining task {}\", e),\n+                }),\n             }\n+        } else {\n+            log::warn!(\"subscription already closed\");\n+            Ok(())\n         }\n     }\n \n     pub fn is_closed(&self) -> bool {\n-        self.is_closed_atomic.load(Ordering::Relaxed)\n+        self.abort_handle.is_finished()\n     }\n }\n \n@@ -1360,15 +1379,15 @@ impl FfiGroupPermissions {\n mod tests {\n     use crate::{\n         get_inbox_id_for_address, inbox_owner::SigningError, logger::FfiLogger,\n-        FfiConversationCallback, FfiCreateGroupOptions, FfiGroupPermissionsOptions, FfiInboxOwner,\n-        FfiListConversationsOptions, FfiListMessagesOptions, FfiMetadataField, FfiPermissionPolicy,\n-        FfiPermissionPolicySet, FfiPermissionUpdateType,\n+        FfiConversationCallback, FfiCreateGroupOptions, FfiGroup, FfiGroupPermissionsOptions,\n+        FfiInboxOwner, FfiListConversationsOptions, FfiListMessagesOptions, FfiMetadataField,\n+        FfiPermissionPolicy, FfiPermissionPolicySet, FfiPermissionUpdateType,\n     };\n     use std::{\n         env,\n         sync::{\n             atomic::{AtomicU32, Ordering},\n-            Arc,\n+            Arc, Mutex,\n         },\n     };\n \n@@ -1378,6 +1397,7 @@ mod tests {\n         self,\n         distributions::{Alphanumeric, DistString},\n     };\n+    use tokio::{sync::Notify, time::error::Elapsed};\n     use xmtp_cryptography::{signature::RecoverableSignature, utils::rng};\n     use xmtp_id::associations::generate_inbox_id;\n     use xmtp_mls::{storage::EncryptionKey, InboxOwner};\n@@ -1417,36 +1437,48 @@ mod tests {\n         }\n     }\n \n-    #[derive(Clone)]\n+    #[derive(Default, Clone)]\n     struct RustStreamCallback {\n         num_messages: Arc<AtomicU32>,\n+        messages: Arc<Mutex<Vec<FfiMessage>>>,\n+        conversations: Arc<Mutex<Vec<Arc<FfiGroup>>>>,\n+        notify: Arc<Notify>,\n     }\n \n     impl RustStreamCallback {\n-        pub fn new() -> Self {\n-            Self {\n-                num_messages: Arc::new(AtomicU32::new(0)),\n-            }\n-        }\n-\n         pub fn message_count(&self) -> u32 {\n             self.num_messages.load(Ordering::SeqCst)\n         }\n+\n+        pub async fn wait_for_delivery(&self) -> Result<(), Elapsed> {\n+            tokio::time::timeout(std::time::Duration::from_secs(60), async {\n+                self.notify.notified().await\n+            })\n+            .await?;\n+            Ok(())\n+        }\n     }\n \n     impl FfiMessageCallback for RustStreamCallback {\n         fn on_message(&self, message: FfiMessage) {\n-            println!(\"Got a message\");\n-            let message = String::from_utf8(message.content).unwrap_or(\"<not UTF8>\".to_string());\n-            log::info!(\"Received: {}\", message);\n+            let mut messages = self.messages.lock().unwrap();\n+            log::info!(\n+                \"ON MESSAGE Received\\n-------- \\n{}\\n----------\",\n+                String::from_utf8_lossy(&message.content)\n+            );\n+            messages.push(message);\n             let _ = self.num_messages.fetch_add(1, Ordering::SeqCst);\n+            self.notify.notify_one();\n         }\n     }\n \n     impl FfiConversationCallback for RustStreamCallback {\n-        fn on_conversation(&self, _: Arc<super::FfiGroup>) {\n-            println!(\"received new conversation\");\n+        fn on_conversation(&self, group: Arc<super::FfiGroup>) {\n+            log::debug!(\"received conversation\");\n             let _ = self.num_messages.fetch_add(1, Ordering::SeqCst);\n+            let mut convos = self.conversations.lock().unwrap();\n+            convos.push(group);\n+            self.notify.notify_one();\n         }\n     }\n \n@@ -1974,13 +2006,11 @@ mod tests {\n         let bo = new_test_client().await;\n \n         // Stream all group messages\n-        let message_callbacks = RustStreamCallback::new();\n+        let message_callbacks = RustStreamCallback::default();\n         let stream_messages = bo\n             .conversations()\n-            .stream_all_messages(Box::new(message_callbacks.clone()))\n-            .await\n-            .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+            .stream_all_messages(Box::new(message_callbacks.clone()));\n+        stream_messages.wait_for_ready().await;\n \n         // Create group and send first message\n         let alix_group = alix\n@@ -1992,12 +2022,11 @@ mod tests {\n             .await\n             .unwrap();\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n-\n         alix_group\n             .update_group_name(\"Old Name\".to_string())\n             .await\n             .unwrap();\n+        message_callbacks.wait_for_delivery().await.unwrap();\n \n         let bo_groups = bo\n             .conversations()\n@@ -2010,41 +2039,35 @@ mod tests {\n             .update_group_name(\"Old Name2\".to_string())\n             .await\n             .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n+        message_callbacks.wait_for_delivery().await.unwrap();\n \n         // Uncomment the following lines to add more group name updates\n-        // alix_group.update_group_name(\"Again Name\".to_string()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n-\n         bo_group\n-            .update_group_name(\"Old Name2\".to_string())\n+            .update_group_name(\"Old Name3\".to_string())\n             .await\n             .unwrap();\n+        message_callbacks.wait_for_delivery().await.unwrap();\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n         assert_eq!(message_callbacks.message_count(), 3);\n \n-        stream_messages.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n+        stream_messages.end_and_wait().await.unwrap();\n+\n         assert!(stream_messages.is_closed());\n     }\n \n     // test is also showing intermittent failures with database locked msg\n-    #[tokio::test(flavor = \"multi_thread\", worker_threads = 5)]\n     #[ignore]\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 5)]\n     async fn test_can_stream_and_update_name_without_forking_group() {\n         let alix = new_test_client().await;\n         let bo = new_test_client().await;\n \n         // Stream all group messages\n-        let message_callbacks = RustStreamCallback::new();\n+        let message_callbacks = RustStreamCallback::default();\n         let stream_messages = bo\n             .conversations()\n-            .stream_all_messages(Box::new(message_callbacks.clone()))\n-            .await\n-            .unwrap();\n-\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+            .stream_all_messages(Box::new(message_callbacks.clone()));\n+        stream_messages.wait_for_ready().await;\n \n         let first_msg_check = 2;\n         let second_msg_check = 5;\n@@ -2059,16 +2082,13 @@ mod tests {\n             .await\n             .unwrap();\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n-\n         alix_group\n             .update_group_name(\"hello\".to_string())\n             .await\n             .unwrap();\n+        message_callbacks.wait_for_delivery().await.unwrap();\n         alix_group.send(\"hello1\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n-        bo.conversations().sync().await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n+        message_callbacks.wait_for_delivery().await.unwrap();\n \n         let bo_groups = bo\n             .conversations()\n@@ -2085,49 +2105,41 @@ mod tests {\n         assert_eq!(bo_messages1.len(), first_msg_check);\n \n         bo_group.send(\"hello2\".as_bytes().to_vec()).await.unwrap();\n+        message_callbacks.wait_for_delivery().await.unwrap();\n         bo_group.send(\"hello3\".as_bytes().to_vec()).await.unwrap();\n+        message_callbacks.wait_for_delivery().await.unwrap();\n+\n         alix_group.sync().await.unwrap();\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n         let alix_messages = alix_group\n             .find_messages(FfiListMessagesOptions::default())\n             .unwrap();\n         assert_eq!(alix_messages.len(), second_msg_check);\n \n         alix_group.send(\"hello4\".as_bytes().to_vec()).await.unwrap();\n+        message_callbacks.wait_for_delivery().await.unwrap();\n         bo_group.sync().await.unwrap();\n \n         let bo_messages2 = bo_group\n             .find_messages(FfiListMessagesOptions::default())\n             .unwrap();\n         assert_eq!(bo_messages2.len(), second_msg_check);\n+        assert_eq!(message_callbacks.message_count(), second_msg_check as u32);\n \n-        // TODO: message_callbacks should eventually come through here, why does this\n-        // not work?\n-        // tokio::time::sleep(tokio::time::Duration::from_millis(10000)).await;\n-        // assert_eq!(message_callbacks.message_count(), second_msg_check as u32);\n-\n-        stream_messages.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n+        stream_messages.end_and_wait().await.unwrap();\n         assert!(stream_messages.is_closed());\n     }\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 5)]\n-    // This one is flaky for me. Passes reliably locally and fails on CI\n-    #[ignore]\n     async fn test_conversation_streaming() {\n         let amal = new_test_client().await;\n         let bola = new_test_client().await;\n \n-        let stream_callback = RustStreamCallback::new();\n+        let stream_callback = RustStreamCallback::default();\n \n         let stream = bola\n             .conversations()\n-            .stream(Box::new(stream_callback.clone()))\n-            .await\n-            .unwrap();\n-\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+            .stream(Box::new(stream_callback.clone()));\n \n         amal.conversations()\n             .create_group(\n@@ -2137,7 +2149,7 @@ mod tests {\n             .await\n             .unwrap();\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n \n         assert_eq!(stream_callback.message_count(), 1);\n         // Create another group and add bola\n@@ -2148,12 +2160,11 @@ mod tests {\n             )\n             .await\n             .unwrap();\n+        stream_callback.wait_for_delivery().await.unwrap();\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n         assert_eq!(stream_callback.message_count(), 2);\n \n-        stream.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n+        stream.end_and_wait().await.unwrap();\n         assert!(stream.is_closed());\n     }\n \n@@ -2171,19 +2182,17 @@ mod tests {\n             )\n             .await\n             .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n \n-        let stream_callback = RustStreamCallback::new();\n+        let stream_callback = RustStreamCallback::default();\n \n         let stream = caro\n             .conversations()\n-            .stream_all_messages(Box::new(stream_callback.clone()))\n-            .await\n-            .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+            .stream_all_messages(Box::new(stream_callback.clone()));\n+        stream.wait_for_ready().await;\n \n         alix_group.send(\"first\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n+\n         let bo_group = bo\n             .conversations()\n             .create_group(\n@@ -2192,27 +2201,26 @@ mod tests {\n             )\n             .await\n             .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;\n+        let _ = caro.inner_client.sync_welcomes().await.unwrap();\n+\n         bo_group.send(\"second\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n         alix_group.send(\"third\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n         bo_group.send(\"fourth\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n \n         assert_eq!(stream_callback.message_count(), 4);\n-        stream.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n+        stream.end_and_wait().await.unwrap();\n         assert!(stream.is_closed());\n     }\n \n-    #[tokio::test(flavor = \"multi_thread\", worker_threads = 5)]\n-    #[ignore]\n+    #[tokio::test(flavor = \"multi_thread\")]\n     async fn test_message_streaming() {\n         let amal = new_test_client().await;\n         let bola = new_test_client().await;\n \n-        let group = amal\n+        let amal_group: Arc<FfiGroup> = amal\n             .conversations()\n             .create_group(\n                 vec![bola.account_address.clone()],\n@@ -2221,19 +2229,25 @@ mod tests {\n             .await\n             .unwrap();\n \n-        let stream_callback = RustStreamCallback::new();\n-        let stream_closer = group\n-            .stream(Box::new(stream_callback.clone()))\n+        bola.inner_client.sync_welcomes().await.unwrap();\n+        let bola_group = bola.group(amal_group.group_id.clone()).unwrap();\n+\n+        let stream_callback = RustStreamCallback::default();\n+        let stream_closer = bola_group.stream(Box::new(stream_callback.clone()));\n+\n+        stream_closer.wait_for_ready().await;\n+\n+        amal_group.send(\"hello\".as_bytes().to_vec()).await.unwrap();\n+        stream_callback.wait_for_delivery().await.unwrap();\n+\n+        amal_group\n+            .send(\"goodbye\".as_bytes().to_vec())\n             .await\n             .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n \n-        group.send(\"hello\".as_bytes().to_vec()).await.unwrap();\n-        group.send(\"goodbye\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;\n         assert_eq!(stream_callback.message_count(), 2);\n-\n-        stream_closer.end();\n+        stream_closer.end_and_wait().await.unwrap();\n     }\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 5)]\n@@ -2254,51 +2268,49 @@ mod tests {\n             )\n             .await\n             .unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n \n-        let stream_callback = RustStreamCallback::new();\n+        let stream_callback = RustStreamCallback::default();\n         let stream_closer = bola\n             .conversations()\n-            .stream_all_messages(Box::new(stream_callback.clone()))\n-            .await\n-            .unwrap();\n+            .stream_all_messages(Box::new(stream_callback.clone()));\n+        stream_closer.wait_for_ready().await;\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+        amal_group.send(b\"hello1\".to_vec()).await.unwrap();\n+        stream_callback.wait_for_delivery().await.unwrap();\n+        amal_group.send(b\"hello2\".to_vec()).await.unwrap();\n+        stream_callback.wait_for_delivery().await.unwrap();\n \n-        amal_group.send(\"hello1\".as_bytes().to_vec()).await.unwrap();\n-        amal_group.send(\"hello2\".as_bytes().to_vec()).await.unwrap();\n-\n-        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;\n         assert_eq!(stream_callback.message_count(), 2);\n         assert!(!stream_closer.is_closed());\n \n         amal_group\n             .remove_members_by_inbox_id(vec![bola.inbox_id().clone()])\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(2000)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n         assert_eq!(stream_callback.message_count(), 3); // Member removal transcript message\n-\n-        amal_group.send(\"hello3\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;\n+                                                        //\n+        amal_group.send(b\"hello3\".to_vec()).await.unwrap();\n+        //TODO: could verify with a log message\n+        tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n         assert_eq!(stream_callback.message_count(), 3); // Don't receive messages while removed\n         assert!(!stream_closer.is_closed());\n \n-        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;\n         amal_group\n             .add_members(vec![bola.account_address.clone()])\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(500)).await;\n+\n+        // TODO: could check for LOG message with a Eviction error on receive\n+        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n         assert_eq!(stream_callback.message_count(), 3); // Don't receive transcript messages while removed\n \n         amal_group.send(\"hello4\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;\n+        stream_callback.wait_for_delivery().await.unwrap();\n         assert_eq!(stream_callback.message_count(), 4); // Receiving messages again\n         assert!(!stream_closer.is_closed());\n \n-        stream_closer.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n+        stream_closer.end_and_wait().await.unwrap();\n         assert!(stream_closer.is_closed());\n     }\n \n@@ -2353,21 +2365,14 @@ mod tests {\n         let bo = new_test_client().await;\n \n         // Stream all group messages\n-        let message_callbacks = RustStreamCallback::new();\n-        let group_callbacks = RustStreamCallback::new();\n-        let stream_groups = bo\n-            .conversations()\n-            .stream(Box::new(group_callbacks.clone()))\n-            .await\n-            .unwrap();\n+        let message_callback = RustStreamCallback::default();\n+        let group_callback = RustStreamCallback::default();\n+        let stream_groups = bo.conversations().stream(Box::new(group_callback.clone()));\n \n         let stream_messages = bo\n             .conversations()\n-            .stream_all_messages(Box::new(message_callbacks.clone()))\n-            .await\n-            .unwrap();\n-\n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n+            .stream_all_messages(Box::new(message_callback.clone()));\n+        stream_messages.wait_for_ready().await;\n \n         // Create group and send first message\n         let alix_group = alix\n@@ -2378,19 +2383,18 @@ mod tests {\n             )\n             .await\n             .unwrap();\n+        group_callback.wait_for_delivery().await.unwrap();\n \n         alix_group.send(\"hello1\".as_bytes().to_vec()).await.unwrap();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;\n+        message_callback.wait_for_delivery().await.unwrap();\n \n-        assert_eq!(group_callbacks.message_count(), 1);\n-        assert_eq!(message_callbacks.message_count(), 1);\n+        assert_eq!(group_callback.message_count(), 1);\n+        assert_eq!(message_callback.message_count(), 1);\n \n-        stream_messages.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n+        stream_messages.end_and_wait().await.unwrap();\n         assert!(stream_messages.is_closed());\n \n-        stream_groups.end();\n-        tokio::time::sleep(tokio::time::Duration::from_millis(5)).await;\n+        stream_groups.end_and_wait().await.unwrap();\n         assert!(stream_groups.is_closed());\n     }\n "
    },
    {
      "filename": "bindings_ffi/src/v2.rs",
      "status": "modified",
      "patch": "@@ -312,9 +312,15 @@ impl FfiV2Subscription {\n         let handle = handle.take();\n         if let Some(h) = handle {\n             h.abort();\n-            h.await.map_err(|_| GenericError::Generic {\n-                err: \"subscription event loop join error\".into(),\n-            })?;\n+            let join_result = h.await;\n+            if matches!(join_result, Err(ref e) if !e.is_cancelled()) {\n+                return Err(GenericError::Generic {\n+                    err: format!(\n+                        \"subscription event loop join error {}\",\n+                        join_result.unwrap_err()\n+                    ),\n+                });\n+            }\n         }\n         Ok(())\n     }"
    },
    {
      "filename": "bindings_node/Cargo.lock",
      "status": "modified",
      "patch": "@@ -300,6 +300,7 @@ version = \"0.0.1\"\n dependencies = [\n  \"futures\",\n  \"hex\",\n+ \"log\",\n  \"napi\",\n  \"napi-build\",\n  \"napi-derive\","
    },
    {
      "filename": "bindings_node/Cargo.toml",
      "status": "modified",
      "patch": "@@ -25,6 +25,7 @@ xmtp_mls = { path = \"../xmtp_mls\", features = [\"grpc\", \"native\"] }\n xmtp_proto = { path = \"../xmtp_proto\", features = [\"proto_full\"] }\n xmtp_id = { path = \"../xmtp_id\" }\n rand = \"0.8.5\"\n+log = { version = \"0.4\", features = [\"release_max_level_debug\"] }\n \n [build-dependencies]\n napi-build = \"2.0.1\""
    },
    {
      "filename": "bindings_node/src/conversations.rs",
      "status": "modified",
      "patch": "@@ -186,9 +186,8 @@ impl NapiConversations {\n     let tsfn: ThreadsafeFunction<NapiGroup, ErrorStrategy::CalleeHandled> =\n       callback.create_threadsafe_function(0, |ctx| Ok(vec![ctx.value]))?;\n     let client = self.inner_client.clone();\n-    let stream_closer = RustXmtpClient::stream_conversations_with_callback(\n-      client.clone(),\n-      move |convo| {\n+    let stream_closer =\n+      RustXmtpClient::stream_conversations_with_callback(client.clone(), move |convo| {\n         tsfn.call(\n           Ok(NapiGroup::new(\n             client.clone(),\n@@ -197,32 +196,22 @@ impl NapiConversations {\n           )),\n           ThreadsafeFunctionCallMode::Blocking,\n         );\n-      },\n-      || {}, // on_close_callback\n-    )\n-    .map_err(|e| Error::from_reason(format!(\"{}\", e)))?;\n+      });\n \n-    Ok(NapiStreamCloser::new(\n-      stream_closer.close_fn,\n-      stream_closer.is_closed_atomic,\n-    ))\n+    Ok(NapiStreamCloser::new(stream_closer))\n   }\n \n   #[napi(ts_args_type = \"callback: (err: null | Error, result: NapiMessage) => void\")]\n   pub fn stream_all_messages(&self, callback: JsFunction) -> Result<NapiStreamCloser> {\n     let tsfn: ThreadsafeFunction<NapiMessage, ErrorStrategy::CalleeHandled> =\n       callback.create_threadsafe_function(0, |ctx| Ok(vec![ctx.value]))?;\n-    let stream_closer = RustXmtpClient::stream_all_messages_with_callback_sync(\n+    let stream_closer = RustXmtpClient::stream_all_messages_with_callback(\n       self.inner_client.clone(),\n       move |message| {\n         tsfn.call(Ok(message.into()), ThreadsafeFunctionCallMode::Blocking);\n       },\n-    )\n-    .map_err(|e| Error::from_reason(format!(\"{}\", e)))?;\n+    );\n \n-    Ok(NapiStreamCloser::new(\n-      stream_closer.close_fn,\n-      stream_closer.is_closed_atomic,\n-    ))\n+    Ok(NapiStreamCloser::new(stream_closer))\n   }\n }"
    },
    {
      "filename": "bindings_node/src/groups.rs",
      "status": "modified",
      "patch": "@@ -562,13 +562,9 @@ impl NapiGroup {\n       move |message| {\n         tsfn.call(Ok(message.into()), ThreadsafeFunctionCallMode::Blocking);\n       },\n-    )\n-    .map_err(|e| Error::from_reason(format!(\"{}\", e)))?;\n+    );\n \n-    Ok(NapiStreamCloser::new(\n-      stream_closer.close_fn,\n-      stream_closer.is_closed_atomic,\n-    ))\n+    Ok(stream_closer.into())\n   }\n \n   #[napi]"
    },
    {
      "filename": "bindings_node/src/streams.rs",
      "status": "modified",
      "patch": "@@ -1,35 +1,73 @@\n-use std::sync::{\n-  atomic::{AtomicBool, Ordering},\n-  Arc, Mutex,\n-};\n-use tokio::sync::oneshot::Sender;\n+use napi::bindgen_prelude::Error;\n+use std::sync::Arc;\n+use tokio::{sync::Mutex, task::AbortHandle};\n+use xmtp_mls::{client::ClientError, subscriptions::StreamHandle};\n \n use napi_derive::napi;\n \n #[napi]\n pub struct NapiStreamCloser {\n-  close_fn: Arc<Mutex<Option<Sender<()>>>>,\n-  is_closed_atomic: Arc<AtomicBool>,\n+  #[allow(clippy::type_complexity)]\n+  handle: Arc<Mutex<Option<StreamHandle<Result<(), ClientError>>>>>,\n+  // for convenience, does not require locking mutex.\n+  abort_handle: Arc<AbortHandle>,\n }\n \n-#[napi]\n impl NapiStreamCloser {\n-  pub fn new(close_fn: Arc<Mutex<Option<Sender<()>>>>, is_closed_atomic: Arc<AtomicBool>) -> Self {\n+  pub fn new(handle: StreamHandle<Result<(), ClientError>>) -> Self {\n     Self {\n-      close_fn,\n-      is_closed_atomic,\n+      abort_handle: Arc::new(handle.handle.abort_handle()),\n+      handle: Arc::new(Mutex::new(Some(handle))),\n     }\n   }\n+}\n+\n+impl From<StreamHandle<Result<(), ClientError>>> for NapiStreamCloser {\n+  fn from(handle: StreamHandle<Result<(), ClientError>>) -> Self {\n+    NapiStreamCloser::new(handle)\n+  }\n+}\n \n+#[napi]\n+impl NapiStreamCloser {\n+  /// Signal the stream to end\n+  /// Does not wait for the stream to end.\n   #[napi]\n   pub fn end(&self) {\n-    if let Ok(mut close_fn_option) = self.close_fn.lock() {\n-      let _ = close_fn_option.take().map(|close_fn| close_fn.send(()));\n+    self.abort_handle.abort();\n+  }\n+\n+  /// End the stream and `await` for it to shutdown\n+  /// Returns the `Result` of the task.\n+  #[napi]\n+  /// End the stream and asyncronously wait for it to shutdown\n+  pub async fn end_and_wait(&self) -> Result<(), Error> {\n+    if self.abort_handle.is_finished() {\n+      return Ok(());\n+    }\n+\n+    let mut stream_handle = self.handle.lock().await;\n+    let stream_handle = stream_handle.take();\n+    if let Some(h) = stream_handle {\n+      h.handle.abort();\n+      match h.handle.await {\n+        Err(e) if !e.is_cancelled() => Err(Error::from_reason(format!(\n+          \"subscription event loop join error {}\",\n+          e\n+        ))),\n+        Err(e) if e.is_cancelled() => Ok(()),\n+        Ok(t) => t.map_err(|e| Error::from_reason(e.to_string())),\n+        Err(e) => Err(Error::from_reason(format!(\"error joining task {}\", e))),\n+      }\n+    } else {\n+      log::warn!(\"subscription already closed\");\n+      Ok(())\n     }\n   }\n \n+  /// Checks if this stream is closed\n   #[napi]\n   pub fn is_closed(&self) -> bool {\n-    self.is_closed_atomic.load(Ordering::Relaxed)\n+    self.abort_handle.is_finished()\n   }\n }"
    },
    {
      "filename": "xmtp_mls/Cargo.toml",
      "status": "modified",
      "patch": "@@ -71,6 +71,8 @@ flume = \"0.11\"\n mockall = \"0.11.4\"\n mockito = \"1.4.0\"\n tempfile = \"3.5.0\"\n+tracing.workspace = true\n+tracing-subscriber.workspace = true\n tracing-log = \"0.2.0\"\n tracing-test = \"0.2.4\"\n xmtp_api_grpc = { path = \"../xmtp_api_grpc\" }"
    },
    {
      "filename": "xmtp_mls/src/groups/subscriptions.rs",
      "status": "modified",
      "patch": "@@ -5,11 +5,10 @@ use std::sync::Arc;\n use futures::Stream;\n \n use super::{extract_message_v1, GroupError, MlsGroup};\n-use crate::retry::Retry;\n use crate::storage::group_message::StoredGroupMessage;\n-use crate::subscriptions::{MessagesStreamInfo, StreamCloser};\n+use crate::subscriptions::{MessagesStreamInfo, StreamHandle};\n use crate::XmtpApi;\n-use crate::{retry_async, Client};\n+use crate::{retry::Retry, retry_async, Client};\n use prost::Message;\n use xmtp_proto::xmtp::mls::api::v1::GroupMessage;\n \n@@ -66,8 +65,10 @@ impl MlsGroup {\n             })\n         );\n \n-        if let Some(GroupError::ReceiveError(_)) = process_result.err() {\n+        if let Some(GroupError::ReceiveError(_)) = process_result.as_ref().err() {\n             self.sync(&client).await?;\n+        } else if process_result.is_err() {\n+            log::error!(\"Process stream entry {:?}\", process_result.err());\n         }\n \n         // Load the message from the DB to handle cases where it may have been already processed in\n@@ -119,11 +120,11 @@ impl MlsGroup {\n         group_id: Vec<u8>,\n         created_at_ns: i64,\n         callback: impl FnMut(StoredGroupMessage) + Send + 'static,\n-    ) -> Result<StreamCloser, GroupError>\n+    ) -> StreamHandle<Result<(), crate::groups::ClientError>>\n     where\n         ApiClient: crate::XmtpApi,\n     {\n-        Ok(Client::<ApiClient>::stream_messages_with_callback(\n+        Client::<ApiClient>::stream_messages_with_callback(\n             client,\n             HashMap::from([(\n                 group_id,\n@@ -133,7 +134,7 @@ impl MlsGroup {\n                 },\n             )]),\n             callback,\n-        )?)\n+        )\n     }\n }\n "
    },
    {
      "filename": "xmtp_mls/src/groups/sync.rs",
      "status": "modified",
      "patch": "@@ -762,6 +762,11 @@ impl MlsGroup {\n                 sha256(payload_slice),\n                 post_commit_data,\n             )?;\n+            log::debug!(\n+                \"client [{}] set stored intent [{}] to state `published`\",\n+                client.inbox_id(),\n+                intent.id\n+            );\n         }\n \n         Ok(())"
    },
    {
      "filename": "xmtp_mls/src/subscriptions.rs",
      "status": "modified",
      "patch": "@@ -1,16 +1,12 @@\n-use std::{\n-    collections::HashMap,\n-    pin::Pin,\n-    sync::{\n-        atomic::{AtomicBool, Ordering},\n-        Arc, Mutex,\n-    },\n-};\n+use std::{collections::HashMap, pin::Pin, sync::Arc};\n \n-use futures::{Stream, StreamExt};\n+use futures::{FutureExt, Stream, StreamExt};\n use prost::Message;\n-use tokio::sync::oneshot::{self, Sender};\n-use tokio_stream::wrappers::errors::BroadcastStreamRecvError;\n+use tokio::{\n+    sync::{mpsc, oneshot},\n+    task::JoinHandle,\n+};\n+use tokio_stream::wrappers::{errors::BroadcastStreamRecvError, UnboundedReceiverStream};\n use xmtp_proto::xmtp::mls::api::v1::WelcomeMessage;\n \n use crate::{\n@@ -19,10 +15,18 @@ use crate::{\n     groups::{extract_group_id, GroupError, MlsGroup},\n     retry::Retry,\n     retry_async,\n-    storage::group_message::StoredGroupMessage,\n+    storage::{group::StoredGroup, group_message::StoredGroupMessage},\n     Client, XmtpApi,\n };\n \n+#[derive(Debug)]\n+/// Wrapper around a [`tokio::task::JoinHandle`] but with a oneshot receiver\n+/// which allows waiting for a `with_callback` stream fn to be ready for stream items.\n+pub struct StreamHandle<T> {\n+    pub handle: JoinHandle<T>,\n+    start: Option<oneshot::Receiver<()>>,\n+}\n+\n /// Events local to this client\n /// are broadcast across all senders/receivers of streams\n #[derive(Clone, Debug)]\n@@ -31,35 +35,39 @@ pub(crate) enum LocalEvents {\n     NewGroup(MlsGroup),\n }\n \n-// TODO simplify FfiStreamCloser + StreamCloser duplication\n-pub struct StreamCloser {\n-    pub close_fn: Arc<Mutex<Option<Sender<()>>>>,\n-    pub is_closed_atomic: Arc<AtomicBool>,\n-}\n-\n-impl StreamCloser {\n-    pub fn end(&self) {\n-        match self.close_fn.lock() {\n-            Ok(mut close_fn_option) => {\n-                let _ = close_fn_option.take().map(|close_fn| close_fn.send(()));\n-            }\n-            _ => {\n-                log::warn!(\"close_fn already closed\");\n-            }\n+impl<T> StreamHandle<T> {\n+    /// Waits for the stream to be fully spawned\n+    pub async fn wait_for_ready(&mut self) {\n+        if let Some(s) = self.start.take() {\n+            let _ = s.await;\n         }\n     }\n+}\n \n-    pub fn is_closed(&self) -> bool {\n-        self.is_closed_atomic.load(Ordering::Relaxed)\n+impl<T> From<StreamHandle<T>> for JoinHandle<T> {\n+    fn from(stream: StreamHandle<T>) -> JoinHandle<T> {\n+        stream.handle\n     }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub(crate) struct MessagesStreamInfo {\n     pub convo_created_at_ns: i64,\n     pub cursor: u64,\n }\n \n+impl From<StoredGroup> for (Vec<u8>, MessagesStreamInfo) {\n+    fn from(group: StoredGroup) -> (Vec<u8>, MessagesStreamInfo) {\n+        (\n+            group.id,\n+            MessagesStreamInfo {\n+                convo_created_at_ns: group.created_at_ns,\n+                cursor: 0,\n+            },\n+        )\n+    }\n+}\n+\n impl<ApiClient> Client<ApiClient>\n where\n     ApiClient: XmtpApi,\n@@ -144,20 +152,19 @@ where\n \n         let subscription = self\n             .api_client\n-            .subscribe_welcome_messages(installation_key, Some(id_cursor as u64))\n+            .subscribe_welcome_messages(installation_key, Some(id_cursor))\n             .await?;\n \n         let stream = subscription\n-            .map(|welcome_result| async {\n+            .map(|welcome| async {\n                 log::info!(\"Received conversation streaming payload\");\n-                let welcome = welcome_result?;\n-                self.process_streamed_welcome(welcome).await\n+                self.process_streamed_welcome(welcome?).await\n             })\n             .filter_map(|res| async {\n                 match res.await {\n                     Ok(group) => Some(group),\n                     Err(err) => {\n-                        log::error!(\"Error processing stream entry: {:?}\", err);\n+                        log::error!(\"Error processing stream entry for conversation: {:?}\", err);\n                         None\n                     }\n                 }\n@@ -166,6 +173,7 @@ where\n         Ok(Box::pin(futures::stream::select(stream, event_queue)))\n     }\n \n+    #[tracing::instrument(skip(self, group_id_to_info))]\n     pub(crate) async fn stream_messages(\n         self: Arc<Self>,\n         group_id_to_info: HashMap<Vec<u8>, MessagesStreamInfo>,\n@@ -228,166 +236,159 @@ where\n     pub fn stream_conversations_with_callback(\n         client: Arc<Client<ApiClient>>,\n         mut convo_callback: impl FnMut(MlsGroup) + Send + 'static,\n-        mut on_close_callback: impl FnMut() + Send + 'static,\n-    ) -> Result<StreamCloser, ClientError> {\n-        let (close_sender, close_receiver) = oneshot::channel::<()>();\n-        let is_closed = Arc::new(AtomicBool::new(false));\n-        let is_closed_clone = is_closed.clone();\n+    ) -> StreamHandle<Result<(), ClientError>> {\n+        let (tx, rx) = oneshot::channel();\n \n-        tokio::spawn(async move {\n+        let handle = tokio::spawn(async move {\n             let mut stream = client.stream_conversations().await.unwrap();\n-            let mut close_receiver = close_receiver;\n-            loop {\n-                tokio::select! {\n-                    item = stream.next() => {\n-                        match item {\n-                            Some(convo) => { convo_callback(convo) },\n-                            None => break\n-                        }\n-                    }\n-                    _ = &mut close_receiver => {\n-                        on_close_callback();\n-                        break;\n-                    }\n-                }\n+            let _ = tx.send(());\n+            while let Some(convo) = stream.next().await {\n+                convo_callback(convo)\n             }\n-            is_closed_clone.store(true, Ordering::Relaxed);\n-            log::info!(\"closing stream\");\n+            Ok(())\n         });\n \n-        Ok(StreamCloser {\n-            close_fn: Arc::new(Mutex::new(Some(close_sender))),\n-            is_closed_atomic: is_closed,\n-        })\n+        StreamHandle {\n+            start: Some(rx),\n+            handle,\n+        }\n     }\n \n     pub(crate) fn stream_messages_with_callback(\n         client: Arc<Client<ApiClient>>,\n         group_id_to_info: HashMap<Vec<u8>, MessagesStreamInfo>,\n         mut callback: impl FnMut(StoredGroupMessage) + Send + 'static,\n-    ) -> Result<StreamCloser, ClientError> {\n-        let (close_sender, close_receiver) = oneshot::channel::<()>();\n-        let is_closed = Arc::new(AtomicBool::new(false));\n-\n-        let is_closed_clone = is_closed.clone();\n-        tokio::spawn(async move {\n-            let mut stream = Self::stream_messages(client, group_id_to_info)\n-                .await\n-                .unwrap();\n-            let mut close_receiver = close_receiver;\n-            loop {\n-                tokio::select! {\n-                    item = stream.next() => {\n-                        match item {\n-                            Some(message) => callback(message),\n-                            None => break\n-                        }\n-                    }\n-                    _ = &mut close_receiver => {\n-                        break;\n-                    }\n-                }\n+    ) -> StreamHandle<Result<(), ClientError>> {\n+        let (tx, rx) = oneshot::channel();\n+\n+        let handle = tokio::spawn(async move {\n+            let mut stream = Self::stream_messages(client, group_id_to_info).await?;\n+            let _ = tx.send(());\n+            while let Some(message) = stream.next().await {\n+                callback(message)\n             }\n-            is_closed_clone.store(true, Ordering::Relaxed);\n-            log::info!(\"closing stream\");\n+            Ok(())\n         });\n \n-        Ok(StreamCloser {\n-            close_fn: Arc::new(Mutex::new(Some(close_sender))),\n-            is_closed_atomic: is_closed,\n-        })\n+        StreamHandle {\n+            start: Some(rx),\n+            handle,\n+        }\n     }\n \n-    pub async fn stream_all_messages_with_callback(\n+    pub async fn stream_all_messages(\n         client: Arc<Client<ApiClient>>,\n-        callback: impl FnMut(StoredGroupMessage) + Send + Sync + 'static,\n-    ) -> Result<StreamCloser, ClientError> {\n-        client.sync_welcomes().await?; // TODO pipe cursor from welcomes sync into groups_stream\n-        Self::stream_all_messages_with_callback_sync(client, callback)\n-    }\n+    ) -> Result<impl Stream<Item = StoredGroupMessage>, ClientError> {\n+        let (tx, rx) = mpsc::unbounded_channel();\n \n-    /// Requires a sync welcomes before use\n-    pub fn stream_all_messages_with_callback_sync(\n-        client: Arc<Client<ApiClient>>,\n-        callback: impl FnMut(StoredGroupMessage) + Send + Sync + 'static,\n-    ) -> Result<StreamCloser, ClientError> {\n-        let callback = Arc::new(Mutex::new(callback));\n+        client.sync_welcomes().await?;\n \n-        let mut group_id_to_info: HashMap<Vec<u8>, MessagesStreamInfo> = client\n+        let mut group_id_to_info = client\n             .store()\n             .conn()?\n             .find_groups(None, None, None, None)?\n             .into_iter()\n-            .map(|group| {\n-                (\n-                    group.id.clone(),\n-                    MessagesStreamInfo {\n-                        convo_created_at_ns: group.created_at_ns,\n-                        cursor: 0,\n+            .map(Into::into)\n+            .collect::<HashMap<Vec<u8>, MessagesStreamInfo>>();\n+\n+        tokio::spawn(async move {\n+            let client = client.clone();\n+            let mut messages_stream = client\n+                .clone()\n+                .stream_messages(group_id_to_info.clone())\n+                .await?;\n+            let mut convo_stream = Self::stream_conversations(&client).await?;\n+            let mut extra_messages = Vec::new();\n+\n+            loop {\n+                tokio::select! {\n+                    // biased enforces an order to select!. If a message and a group are both ready\n+                    // at the same time, `biased` mode will process the message before the new\n+                    // group.\n+                    biased;\n+\n+                    messages = futures::future::ready(&mut extra_messages), if !extra_messages.is_empty() => {\n+                        for message in messages.drain(0..) {\n+                            if tx.send(message).is_err() {\n+                                break;\n+                            }\n+                        }\n                     },\n-                )\n-            })\n-            .collect();\n+                    Some(message) = messages_stream.next() => {\n+                        // an error can only mean the receiver has been dropped or closed so we're\n+                        // safe to end the stream\n+                        if tx.send(message).is_err() {\n+                            break;\n+                        }\n+                    }\n+                    Some(new_group) = convo_stream.next() => {\n+                        if tx.is_closed() {\n+                            break;\n+                        }\n+                        if group_id_to_info.contains_key(&new_group.group_id) {\n+                            continue;\n+                        }\n \n-        let callback_clone = callback.clone();\n-        let messages_stream_closer_mutex =\n-            Arc::new(Mutex::new(Self::stream_messages_with_callback(\n-                client.clone(),\n-                group_id_to_info.clone(),\n-                move |message| callback_clone.lock().unwrap()(message), // TODO fix unwrap\n-            )?));\n-        let messages_stream_closer_mutex_clone = messages_stream_closer_mutex.clone();\n-        let groups_stream_closer = Self::stream_conversations_with_callback(\n-            client.clone(),\n-            move |convo| {\n-                // TODO make sure key comparison works correctly\n-                if group_id_to_info.contains_key(&convo.group_id) {\n-                    return;\n-                }\n-                // Close existing message stream\n-                // TODO remove unwrap\n-                let mut messages_stream_closer = messages_stream_closer_mutex.lock().unwrap();\n-                messages_stream_closer.end();\n-\n-                // Set up new stream. For existing groups, stream new messages only by unsetting the cursor\n-                for info in group_id_to_info.values_mut() {\n-                    info.cursor = 0;\n-                }\n-                group_id_to_info.insert(\n-                    convo.group_id,\n-                    MessagesStreamInfo {\n-                        convo_created_at_ns: convo.created_at_ns,\n-                        cursor: 1, // For the new group, stream all messages since the group was created\n+                        for info in group_id_to_info.values_mut() {\n+                            info.cursor = 0;\n+                        }\n+                        group_id_to_info.insert(\n+                            new_group.group_id,\n+                            MessagesStreamInfo {\n+                                convo_created_at_ns: new_group.created_at_ns,\n+                                cursor: 1, // For the new group, stream all messages since the group was created\n+                            },\n+                        );\n+                        let new_messages_stream = client.clone().stream_messages(group_id_to_info.clone()).await?;\n+\n+                        // attempt to drain all ready messages from existing stream\n+                        while let Some(Some(message)) = messages_stream.next().now_or_never() {\n+                            extra_messages.push(message);\n+                        }\n+                        let _ = std::mem::replace(&mut messages_stream, new_messages_stream);\n                     },\n-                );\n-\n-                // Open new message stream\n-                let callback_clone = callback.clone();\n-                *messages_stream_closer = Self::stream_messages_with_callback(\n-                    client.clone(),\n-                    group_id_to_info.clone(),\n-                    move |message| callback_clone.lock().unwrap()(message), // TODO fix unwrap\n-                )\n-                .unwrap(); // TODO fix unwrap\n-            },\n-            move || {\n-                messages_stream_closer_mutex_clone.lock().unwrap().end();\n-            },\n-        )?;\n+                }\n+            }\n+            Ok::<_, ClientError>(())\n+        });\n \n-        Ok(groups_stream_closer)\n+        Ok(UnboundedReceiverStream::new(rx))\n+    }\n+\n+    pub fn stream_all_messages_with_callback(\n+        client: Arc<Client<ApiClient>>,\n+        mut callback: impl FnMut(StoredGroupMessage) + Send + Sync + 'static,\n+    ) -> StreamHandle<Result<(), ClientError>> {\n+        let (tx, rx) = oneshot::channel();\n+\n+        let handle = tokio::spawn(async move {\n+            let mut stream = Self::stream_all_messages(client).await?;\n+            let _ = tx.send(());\n+            while let Some(message) = stream.next().await {\n+                callback(message)\n+            }\n+            Ok(())\n+        });\n+\n+        StreamHandle {\n+            start: Some(rx),\n+            handle,\n+        }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n+    use crate::utils::test::Delivery;\n     use crate::{\n         builder::ClientBuilder, groups::GroupMetadataOptions,\n         storage::group_message::StoredGroupMessage, Client,\n     };\n     use futures::StreamExt;\n-    use std::sync::{Arc, Mutex};\n-    use tokio::sync::Notify;\n+    use std::sync::{\n+        atomic::{AtomicU64, Ordering},\n+        Arc, Mutex,\n+    };\n     use xmtp_api_grpc::grpc_api_helper::Client as GrpcClient;\n     use xmtp_cryptography::utils::generate_local_wallet;\n \n@@ -435,47 +436,49 @@ mod tests {\n \n         let messages: Arc<Mutex<Vec<StoredGroupMessage>>> = Arc::new(Mutex::new(Vec::new()));\n         let messages_clone = messages.clone();\n-        let stream = Client::<GrpcClient>::stream_all_messages_with_callback(\n+\n+        let notify = Delivery::new();\n+        let notify_pointer = notify.clone();\n+        let mut handle = Client::<GrpcClient>::stream_all_messages_with_callback(\n             Arc::new(caro),\n             move |message| {\n                 (*messages_clone.lock().unwrap()).push(message);\n+                notify_pointer.notify_one();\n             },\n-        )\n-        .await\n-        .unwrap();\n-\n-        tokio::time::sleep(std::time::Duration::from_millis(50)).await;\n+        );\n+        handle.wait_for_ready().await;\n \n         alix_group\n             .send_message(\"first\".as_bytes(), &alix)\n             .await\n             .unwrap();\n+        notify.wait_for_delivery().await.unwrap();\n         bo_group\n             .send_message(\"second\".as_bytes(), &bo)\n             .await\n             .unwrap();\n+        notify.wait_for_delivery().await.unwrap();\n         alix_group\n             .send_message(\"third\".as_bytes(), &alix)\n             .await\n             .unwrap();\n+        notify.wait_for_delivery().await.unwrap();\n         bo_group\n             .send_message(\"fourth\".as_bytes(), &bo)\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n+        notify.wait_for_delivery().await.unwrap();\n \n         let messages = messages.lock().unwrap();\n-        assert_eq!(messages[0].decrypted_message_bytes, \"first\".as_bytes());\n-        assert_eq!(messages[1].decrypted_message_bytes, \"second\".as_bytes());\n-        assert_eq!(messages[2].decrypted_message_bytes, \"third\".as_bytes());\n-        assert_eq!(messages[3].decrypted_message_bytes, \"fourth\".as_bytes());\n-\n-        stream.end();\n+        assert_eq!(messages[0].decrypted_message_bytes, b\"first\");\n+        assert_eq!(messages[1].decrypted_message_bytes, b\"second\");\n+        assert_eq!(messages[2].decrypted_message_bytes, b\"third\");\n+        assert_eq!(messages[3].decrypted_message_bytes, b\"fourth\");\n     }\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 10)]\n     async fn test_stream_all_messages_changing_group_list() {\n-        let alix = ClientBuilder::new_test_client(&generate_local_wallet()).await;\n+        let alix = Arc::new(ClientBuilder::new_test_client(&generate_local_wallet()).await);\n         let bo = ClientBuilder::new_test_client(&generate_local_wallet()).await;\n         let caro = Arc::new(ClientBuilder::new_test_client(&generate_local_wallet()).await);\n \n@@ -487,27 +490,22 @@ mod tests {\n             .await\n             .unwrap();\n \n-        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n-\n         let messages: Arc<Mutex<Vec<StoredGroupMessage>>> = Arc::new(Mutex::new(Vec::new()));\n         let messages_clone = messages.clone();\n-        let stream =\n+        let delivery = Delivery::new();\n+        let delivery_pointer = delivery.clone();\n+        let mut handle =\n             Client::<GrpcClient>::stream_all_messages_with_callback(caro.clone(), move |message| {\n-                let text = String::from_utf8(message.decrypted_message_bytes.clone())\n-                    .unwrap_or(\"<not UTF8>\".to_string());\n-                println!(\"Received: {}\", text);\n+                delivery_pointer.notify_one();\n                 (*messages_clone.lock().unwrap()).push(message);\n-            })\n-            .await\n-            .unwrap();\n-\n-        tokio::time::sleep(std::time::Duration::from_millis(50)).await;\n+            });\n+        handle.wait_for_ready().await;\n \n         alix_group\n             .send_message(\"first\".as_bytes(), &alix)\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n+        delivery.wait_for_delivery().await.unwrap();\n \n         let bo_group = bo\n             .create_group(None, GroupMetadataOptions::default())\n@@ -516,19 +514,18 @@ mod tests {\n             .add_members_by_inbox_id(&bo, vec![caro.inbox_id()])\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(300)).await;\n \n         bo_group\n             .send_message(\"second\".as_bytes(), &bo)\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n+        delivery.wait_for_delivery().await.unwrap();\n \n         alix_group\n             .send_message(\"third\".as_bytes(), &alix)\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n+        delivery.wait_for_delivery().await.unwrap();\n \n         let alix_group_2 = alix\n             .create_group(None, GroupMetadataOptions::default())\n@@ -537,31 +534,31 @@ mod tests {\n             .add_members_by_inbox_id(&alix, vec![caro.inbox_id()])\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(300)).await;\n \n         alix_group\n             .send_message(\"fourth\".as_bytes(), &alix)\n             .await\n             .unwrap();\n-        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n+        delivery.wait_for_delivery().await.unwrap();\n+\n         alix_group_2\n             .send_message(\"fifth\".as_bytes(), &alix)\n             .await\n             .unwrap();\n-\n-        tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n+        delivery.wait_for_delivery().await.unwrap();\n \n         {\n             let messages = messages.lock().unwrap();\n             assert_eq!(messages.len(), 5);\n         }\n \n-        stream.end();\n-        tokio::time::sleep(std::time::Duration::from_millis(50)).await;\n-        assert!(stream.is_closed());\n+        let a = handle.handle.abort_handle();\n+        a.abort();\n+        let _ = handle.handle.await;\n+        assert!(a.is_finished());\n \n         alix_group\n-            .send_message(\"first\".as_bytes(), &alix)\n+            .send_message(\"should not show up\".as_bytes(), &alix)\n             .await\n             .unwrap();\n         tokio::time::sleep(std::time::Duration::from_millis(100)).await;\n@@ -570,34 +567,96 @@ mod tests {\n         assert_eq!(messages.len(), 5);\n     }\n \n+    #[ignore]\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 10)]\n+    async fn test_stream_all_messages_does_not_lose_messages() {\n+        let alix = Arc::new(ClientBuilder::new_test_client(&generate_local_wallet()).await);\n+        let caro = Arc::new(ClientBuilder::new_test_client(&generate_local_wallet()).await);\n+\n+        let alix_group = alix\n+            .create_group(None, GroupMetadataOptions::default())\n+            .unwrap();\n+        alix_group\n+            .add_members_by_inbox_id(&alix, vec![caro.inbox_id()])\n+            .await\n+            .unwrap();\n+\n+        let messages: Arc<Mutex<Vec<StoredGroupMessage>>> = Arc::new(Mutex::new(Vec::new()));\n+        let messages_clone = messages.clone();\n+\n+        let blocked = Arc::new(AtomicU64::new(55));\n+\n+        let blocked_pointer = blocked.clone();\n+        let mut handle =\n+            Client::<GrpcClient>::stream_all_messages_with_callback(caro.clone(), move |message| {\n+                (*messages_clone.lock().unwrap()).push(message);\n+                blocked_pointer.fetch_sub(1, Ordering::SeqCst);\n+            });\n+        handle.wait_for_ready().await;\n+\n+        let alix_group_pointer = alix_group.clone();\n+        let alix_pointer = alix.clone();\n+        tokio::spawn(async move {\n+            for _ in 0..50 {\n+                alix_group_pointer\n+                    .send_message(b\"spam\", &alix_pointer)\n+                    .await\n+                    .unwrap();\n+                tokio::time::sleep(std::time::Duration::from_micros(200)).await;\n+            }\n+        });\n+\n+        for _ in 0..5 {\n+            let new_group = alix\n+                .create_group(None, GroupMetadataOptions::default())\n+                .unwrap();\n+            new_group\n+                .add_members_by_inbox_id(&alix, vec![caro.inbox_id()])\n+                .await\n+                .unwrap();\n+            new_group\n+                .send_message(b\"spam from new group\", &alix)\n+                .await\n+                .unwrap();\n+        }\n+\n+        let _ = tokio::time::timeout(std::time::Duration::from_secs(120), async {\n+            while blocked.load(Ordering::SeqCst) > 0 {\n+                tokio::task::yield_now().await;\n+            }\n+        })\n+        .await;\n+\n+        let missed_messages = blocked.load(Ordering::SeqCst);\n+        if missed_messages > 0 {\n+            println!(\"Missed {} Messages\", missed_messages);\n+            panic!(\"Test failed due to missed messages\");\n+        }\n+    }\n+\n     #[tokio::test(flavor = \"multi_thread\")]\n     async fn test_self_group_creation() {\n         let alix = Arc::new(ClientBuilder::new_test_client(&generate_local_wallet()).await);\n         let bo = Arc::new(ClientBuilder::new_test_client(&generate_local_wallet()).await);\n \n         let groups = Arc::new(Mutex::new(Vec::new()));\n-        let notify = Arc::new(Notify::new());\n+        let notify = Delivery::new();\n         let (notify_pointer, groups_pointer) = (notify.clone(), groups.clone());\n \n-        let closer = Client::<GrpcClient>::stream_conversations_with_callback(\n-            alix.clone(),\n-            move |g| {\n+        let closer =\n+            Client::<GrpcClient>::stream_conversations_with_callback(alix.clone(), move |g| {\n                 let mut groups = groups_pointer.lock().unwrap();\n                 groups.push(g);\n                 notify_pointer.notify_one();\n-            },\n-            || {},\n-        )\n-        .unwrap();\n+            });\n \n         alix.create_group(None, GroupMetadataOptions::default())\n             .unwrap();\n \n-        tokio::time::timeout(std::time::Duration::from_secs(60), async {\n-            notify.notified().await\n-        })\n-        .await\n-        .expect(\"Stream never received group\");\n+        notify\n+            .wait_for_delivery()\n+            .await\n+            .expect(\"Stream never received group\");\n \n         {\n             let grps = groups.lock().unwrap();\n@@ -612,17 +671,13 @@ mod tests {\n             .await\n             .unwrap();\n \n-        tokio::time::timeout(std::time::Duration::from_secs(60), async {\n-            notify.notified().await\n-        })\n-        .await\n-        .expect(\"Stream never received group\");\n+        notify.wait_for_delivery().await.unwrap();\n \n         {\n             let grps = groups.lock().unwrap();\n             assert_eq!(grps.len(), 2);\n         }\n \n-        closer.end();\n+        closer.handle.abort();\n     }\n }"
    },
    {
      "filename": "xmtp_mls/src/utils/test.rs",
      "status": "modified",
      "patch": "@@ -4,6 +4,8 @@ use rand::{\n     distributions::{Alphanumeric, DistString},\n     Rng,\n };\n+use std::sync::Arc;\n+use tokio::{sync::Notify, time::error::Elapsed};\n use xmtp_api_grpc::grpc_api_helper::Client as GrpcClient;\n use xmtp_id::associations::{generate_inbox_id, RecoverableEcdsaSignature};\n \n@@ -111,6 +113,31 @@ impl ClientBuilder<GrpcClient> {\n     }\n }\n \n+/// wrapper over a `Notify` with a 60-scond timeout for waiting\n+#[derive(Clone, Default)]\n+pub struct Delivery {\n+    notify: Arc<Notify>,\n+}\n+\n+impl Delivery {\n+    pub fn new() -> Self {\n+        Self {\n+            notify: Arc::new(Notify::new()),\n+        }\n+    }\n+\n+    pub async fn wait_for_delivery(&self) -> Result<(), Elapsed> {\n+        tokio::time::timeout(std::time::Duration::from_secs(60), async {\n+            self.notify.notified().await\n+        })\n+        .await\n+    }\n+\n+    pub fn notify_one(&self) {\n+        self.notify.notify_one()\n+    }\n+}\n+\n impl Client<GrpcClient> {\n     pub async fn is_registered(&self, address: &String) -> bool {\n         let ids = self"
    }
  ],
  "fix_category": "Change timeout to barrier",
  "root_cause_category": "Async Wait",
  "root_cause_subcategory": "Wait/Join"
}