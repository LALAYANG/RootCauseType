{
  "id": 62,
  "repo": "subxt",
  "issue_url": "https://github.com/paritytech/subxt/issues/1248",
  "pr_url": "https://github.com/paritytech/subxt/pull/1300",
  "issue_description": "Detected by https://github.com/paritytech/subxt/actions/runs/6771722241/job/18402732995?pr=1238.\r\n\r\n\r\n```\r\n--- STDOUT:              integration-tests full_client::frame::balances::tx_basic_transfer ---\r\nfailures:\r\n    full_client::frame::balances::tx_basic_transfer\r\n\r\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 77 filtered out; finished in 50.34s\r\n\r\n\r\n--- STDERR:              integration-tests full_client::frame::balances::tx_basic_transfer ---\r\nthread 'full_client::frame::balances::tx_basic_transfer' panicked at testing/integration-tests/src/full_client/frame/balances.rs:83:5:\r\nassertion failed: alice_pre.data.free - 10_000 >= alice_post.data.free\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n```",
  "files_changed": [
    {
      "filename": "subxt/src/tx/tx_progress.rs",
      "status": "modified",
      "patch": "@@ -10,6 +10,7 @@ use crate::utils::strip_compact_prefix;\n use crate::{\n     backend::{BlockRef, StreamOfResults, TransactionStatus as BackendTxStatus},\n     client::OnlineClientT,\n+    config::Header,\n     error::{DispatchError, Error, RpcError, TransactionError},\n     events::EventsClient,\n     Config,\n@@ -82,6 +83,20 @@ where\n     /// that this is true. In those cases the stream is closed however, so you currently have no way to find\n     /// out if they finally made it into a block or not.\n     pub async fn wait_for_finalized(mut self) -> Result<TxInBlock<T, C>, Error> {\n+        // Wait for the tx to be reported in a block by the transaction status.\n+        let tx_in_block = self.wait_for_tx_finalized().await?;\n+\n+        // Tx reported as finalized must be synchronized with the chain head:\n+        // - tx finalized number must be lower than the chain head finalized number.\n+        // - tx finalized hash must be equal to the chain head finalized hash.\n+        self.wait_for_chain_head_finalized(tx_in_block).await\n+    }\n+\n+    /// Wait for the transaction to be reported as finalized.\n+    ///\n+    /// This relies entirely by the transaction status, that could be out of sync with\n+    /// the chain head.\n+    async fn wait_for_tx_finalized(&mut self) -> Result<TxInBlock<T, C>, Error> {\n         while let Some(status) = self.next().await {\n             match status? {\n                 // Finalized! Return.\n@@ -101,6 +116,80 @@ where\n         Err(RpcError::SubscriptionDropped.into())\n     }\n \n+    /// Wait for the block hash of the transaction to be reported as finalized\n+    /// by the chain head.\n+    async fn wait_for_chain_head_finalized(\n+        &mut self,\n+        tx_in_block: TxInBlock<T, C>,\n+    ) -> Result<TxInBlock<T, C>, Error> {\n+        // Correlate the tx status with the head of the chain.\n+        let head = self.client.backend().latest_finalized_block_ref().await?;\n+\n+        // This optimizes the most common case, where the tx status is in sync with the head of the chain.\n+        if tx_in_block.block_hash() == head.hash() {\n+            return Ok(tx_in_block);\n+        }\n+\n+        // Must determine if the hash is older or newer than the chain head.\n+        let Some(tx_num) = self\n+            .client\n+            .backend()\n+            .block_header(tx_in_block.block_hash())\n+            .await?\n+            .map(|header: <T as Config>::Header| header.number())\n+        else {\n+            return Err(TransactionError::Error(\n+                \"Transaction block header not found. This is a bug, please open an issue\".into(),\n+            )\n+            .into());\n+        };\n+\n+        let Some(head_num) = self\n+            .client\n+            .backend()\n+            .block_header(head.hash())\n+            .await?\n+            .map(|header| header.number())\n+        else {\n+            return Err(TransactionError::Error(\n+                \"Chain finalized block header not found. This is a bug, please open an issue\"\n+                    .into(),\n+            )\n+            .into());\n+        };\n+\n+        let tx_num: u64 = tx_num.into();\n+        let head_num: u64 = head_num.into();\n+        // Rely on substrate to report a valid TX status included in a prior finalized block.\n+        if tx_num < head_num {\n+            return Ok(tx_in_block);\n+        }\n+\n+        // Wait for the chain head to report the tx block hash as finalized, or to report\n+        // a newer finalized block hash (in terms of block number).\n+        let mut finalized_stream = self\n+            .client\n+            .backend()\n+            .stream_finalized_block_headers()\n+            .await?;\n+\n+        while let Some(finalized) = finalized_stream.next().await {\n+            let (finalized, _block_ref) = finalized?;\n+\n+            // By the time we open this subscription stream, tx finalized number may (very unlikely) lag behind.\n+            let finalized_num = finalized.number().into();\n+            if tx_num < finalized_num {\n+                return Ok(tx_in_block);\n+            }\n+\n+            if finalized.hash() == tx_in_block.block_hash() {\n+                return Ok(tx_in_block);\n+            }\n+        }\n+\n+        Ok(tx_in_block)\n+    }\n+\n     /// Wait for the transaction to be finalized, and for the transaction events to indicate\n     /// that the transaction was successful. Returns the events associated with the transaction,\n     /// as well as a couple of other details (block hash and extrinsic hash)."
    }
  ],
  "fix_category": "Support failure case",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Robustness"
}