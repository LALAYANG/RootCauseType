{
  "id": 72,
  "repo": "arrow-rs",
  "issue_url": "https://github.com/apache/arrow-rs/issues/3490",
  "pr_url": "https://github.com/apache/arrow-rs/pull/3532",
  "issue_description": "**Is your feature request related to a problem or challenge? Please describe what you are trying to do.**\r\n<!--\r\nA clear and concise description of what the problem is. Ex. I'm always frustrated when [...] \r\n(This section helps Arrow developers understand the context and *why* for this feature, in addition to  the *what*)\r\n-->\r\n\r\nCurrently the object_store crate only supports obtaining credentials using a provided service account, it would be beneficial if it could also optionally obtain credentials from its environment. This would be consistent with the behaviour of the aws and azure implementations, and avoids requiring users to handle sensitive long-term service account credentials.\r\n\r\n**Describe the solution you'd like**\r\n<!--\r\nA clear and concise description of what you want to happen.\r\n-->\r\n\r\nIf no service account is specified, it should fallback to trying to get credentials from a metadata endpoint. \r\n\r\nThis is documented [here](https://cloud.google.com/docs/authentication/get-id-token#metadata-server)\r\n\r\n**Describe alternatives you've considered**\r\n<!--\r\nA clear and concise description of any alternative solutions or features you've considered.\r\n-->\r\n\r\n**Additional context**\r\n<!--\r\nAdd any other context or screenshots about the feature request here.\r\n-->\r\n",
  "files_changed": [
    {
      "filename": "object_store/Cargo.toml",
      "status": "modified",
      "patch": "@@ -32,7 +32,9 @@ all-features = true\n async-trait = \"0.1.53\"\n bytes = \"1.0\"\n chrono = { version = \"0.4.23\", default-features = false, features = [\"clock\"] }\n+dirs = \"4.0\"\n futures = \"0.3\"\n+gcp_auth = \"0.7.5\"\n itertools = \"0.10.1\"\n parking_lot = { version = \"0.12\" }\n percent-encoding = \"2.1\""
    },
    {
      "filename": "object_store/src/gcp/credential.rs",
      "status": "modified",
      "patch": "@@ -108,7 +108,6 @@ struct TokenResponse {\n #[derive(Debug)]\n pub struct OAuthProvider {\n     issuer: String,\n-    scope: String,\n     audience: String,\n     key_pair: RsaKeyPair,\n     jwt_header: String,\n@@ -120,7 +119,6 @@ impl OAuthProvider {\n     pub fn new(\n         issuer: String,\n         private_key_pem: String,\n-        scope: String,\n         audience: String,\n     ) -> Result<Self> {\n         let key_pair = decode_first_rsa_key(private_key_pem)?;\n@@ -132,7 +130,6 @@ impl OAuthProvider {\n         Ok(Self {\n             issuer,\n             key_pair,\n-            scope,\n             audience,\n             jwt_header,\n             random: ring::rand::SystemRandom::new(),\n@@ -142,6 +139,7 @@ impl OAuthProvider {\n     /// Fetch a fresh token\n     pub async fn fetch_token(\n         &self,\n+        scope: &str,\n         client: &Client,\n         retry: &RetryConfig,\n     ) -> Result<TemporaryToken<String>> {\n@@ -150,7 +148,7 @@ impl OAuthProvider {\n \n         let claims = TokenClaims {\n             iss: &self.issuer,\n-            scope: &self.scope,\n+            scope: scope,\n             aud: &self.audience,\n             exp,\n             iat: now,"
    },
    {
      "filename": "object_store/src/gcp/mod.rs",
      "status": "modified",
      "patch": "@@ -29,6 +29,8 @@\n //! to abort the upload and drop those unneeded parts. In addition, you may wish to\n //! consider implementing automatic clean up of unused parts that are older than one\n //! week.\n+use futures::lock::Mutex;\n+use gcp_auth::AuthenticationManager;\n use std::collections::BTreeSet;\n use std::fs::File;\n use std::io::{self, BufReader};\n@@ -155,6 +157,9 @@ enum Error {\n \n     #[snafu(display(\"Configuration key: '{}' is not known.\", key))]\n     UnknownConfigurationKey { key: String },\n+\n+    #[snafu(display(\"Error generating token: {}\", source))]\n+    Token { source: gcp_auth::Error },\n }\n \n impl From<Error> for super::Error {\n@@ -262,13 +267,30 @@ impl std::fmt::Display for GoogleCloudStorage {\n     }\n }\n \n+/// Control the authentication manager:\n+///   - disable when configured (during testing)\n+///   - delay initialization since an async context is needed\n+///   - implement Debug\n+struct AuthenticationManagerW {\n+    disabled: bool,\n+    inner: Mutex<Option<AuthenticationManager>>,\n+}\n+impl std::fmt::Debug for AuthenticationManagerW {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_tuple(\"AuthenticationManager\")\n+            .field(&self.disabled)\n+            .finish()\n+    }\n+}\n+\n #[derive(Debug)]\n struct GoogleCloudStorageClient {\n     client: Client,\n     base_url: String,\n \n     oauth_provider: Option<OAuthProvider>,\n     token_cache: TokenCache<String>,\n+    authentication_manager: AuthenticationManagerW,\n \n     bucket_name: String,\n     bucket_name_encoded: String,\n@@ -281,17 +303,33 @@ struct GoogleCloudStorageClient {\n }\n \n impl GoogleCloudStorageClient {\n-    async fn get_token(&self) -> Result<String> {\n-        if let Some(oauth_provider) = &self.oauth_provider {\n-            Ok(self\n+    async fn get_token(&self, scope: Option<&str>) -> Result<String> {\n+        let scope =\n+            scope.unwrap_or(\"https://www.googleapis.com/auth/devstorage.full_control\");\n+        match &self.oauth_provider {\n+            Some(oauth_provider) => Ok(self\n                 .token_cache\n                 .get_or_insert_with(|| {\n-                    oauth_provider.fetch_token(&self.client, &self.retry_config)\n+                    oauth_provider.fetch_token(scope, &self.client, &self.retry_config)\n                 })\n                 .await\n-                .context(CredentialSnafu)?)\n-        } else {\n-            Ok(\"\".to_owned())\n+                .context(CredentialSnafu)?),\n+            None if !self.authentication_manager.disabled => {\n+                let mut locked = self.authentication_manager.inner.lock().await;\n+                if locked.as_ref().is_none() {\n+                    *locked =\n+                        Some(AuthenticationManager::new().await.context(TokenSnafu)?);\n+                }\n+                Ok(locked\n+                    .as_ref()\n+                    .unwrap()\n+                    .get_token(&[scope])\n+                    .await\n+                    .context(TokenSnafu)?\n+                    .as_str()\n+                    .to_owned())\n+            }\n+            _ => Ok(\"\".to_owned()),\n         }\n     }\n \n@@ -311,7 +349,7 @@ impl GoogleCloudStorageClient {\n         range: Option<Range<usize>>,\n         head: bool,\n     ) -> Result<Response> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n         let url = self.object_url(path);\n \n         let mut builder = self.client.request(Method::GET, url);\n@@ -339,7 +377,7 @@ impl GoogleCloudStorageClient {\n \n     /// Perform a put request <https://cloud.google.com/storage/docs/json_api/v1/objects/insert>\n     async fn put_request(&self, path: &Path, payload: Bytes) -> Result<()> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n         let url = format!(\n             \"{}/upload/storage/v1/b/{}/o\",\n             self.base_url, self.bucket_name_encoded\n@@ -366,7 +404,7 @@ impl GoogleCloudStorageClient {\n \n     /// Initiate a multi-part upload <https://cloud.google.com/storage/docs/xml-api/post-object-multipart>\n     async fn multipart_initiate(&self, path: &Path) -> Result<MultipartId> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n         let url = format!(\"{}/{}/{}\", self.base_url, self.bucket_name_encoded, path);\n \n         let content_type = self\n@@ -404,7 +442,7 @@ impl GoogleCloudStorageClient {\n         path: &str,\n         multipart_id: &MultipartId,\n     ) -> Result<()> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n         let url = format!(\"{}/{}/{}\", self.base_url, self.bucket_name_encoded, path);\n \n         self.client\n@@ -422,7 +460,7 @@ impl GoogleCloudStorageClient {\n \n     /// Perform a delete request <https://cloud.google.com/storage/docs/json_api/v1/objects/delete>\n     async fn delete_request(&self, path: &Path) -> Result<()> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n         let url = self.object_url(path);\n \n         let builder = self.client.request(Method::DELETE, url);\n@@ -444,7 +482,7 @@ impl GoogleCloudStorageClient {\n         to: &Path,\n         if_not_exists: bool,\n     ) -> Result<()> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n \n         let source =\n             percent_encoding::utf8_percent_encode(from.as_ref(), NON_ALPHANUMERIC);\n@@ -497,7 +535,7 @@ impl GoogleCloudStorageClient {\n         delimiter: bool,\n         page_token: Option<&str>,\n     ) -> Result<ListResponse> {\n-        let token = self.get_token().await?;\n+        let token = self.get_token(None).await?;\n \n         let url = format!(\n             \"{}/storage/v1/b/{}/o\",\n@@ -576,7 +614,7 @@ impl CloudMultiPartUploadImpl for GCSMultipartUpload {\n \n         let token = self\n             .client\n-            .get_token()\n+            .get_token(None)\n             .await\n             .map_err(|err| io::Error::new(io::ErrorKind::Other, err))?;\n \n@@ -630,7 +668,7 @@ impl CloudMultiPartUploadImpl for GCSMultipartUpload {\n \n         let token = self\n             .client\n-            .get_token()\n+            .get_token(None)\n             .await\n             .map_err(|err| io::Error::new(io::ErrorKind::Other, err))?;\n \n@@ -1099,28 +1137,34 @@ impl GoogleCloudStorageBuilder {\n         let client = self.client_options.client()?;\n \n         let credentials = match (self.service_account_path, self.service_account_key) {\n-            (Some(path), None) => reader_credentials_file(path)?,\n+            (Some(path), None) => Some(reader_credentials_file(path)?),\n             (None, Some(key)) => {\n-                serde_json::from_str(&key).context(DecodeCredentialsSnafu)?\n+                Some(serde_json::from_str(&key).context(DecodeCredentialsSnafu)?)\n             }\n-            (None, None) => return Err(Error::MissingServiceAccountPathOrKey.into()),\n+            (None, None) => None,\n             (Some(_), Some(_)) => {\n                 return Err(Error::ServiceAccountPathAndKeyProvided.into())\n             }\n         };\n \n         // TODO: https://cloud.google.com/storage/docs/authentication#oauth-scopes\n-        let scope = \"https://www.googleapis.com/auth/devstorage.full_control\";\n         let audience = \"https://www.googleapis.com/oauth2/v4/token\".to_string();\n \n-        let oauth_provider = (!credentials.disable_oauth)\n-            .then(|| {\n-                OAuthProvider::new(\n-                    credentials.client_email,\n-                    credentials.private_key,\n-                    scope.to_string(),\n-                    audience,\n-                )\n+        let disable_oauth = credentials\n+            .as_ref()\n+            .map(|c| c.disable_oauth)\n+            .unwrap_or(false);\n+        let base_url = credentials.as_ref()\n+            .map(|c| c.gcs_base_url.clone())\n+            .unwrap_or_else(|| default_gcs_base_url());\n+\n+        let oauth_provider = credentials\n+            .and_then(|c| {\n+                if c.disable_oauth {\n+                    None\n+                } else {\n+                    Some(OAuthProvider::new(c.client_email, c.private_key, audience))\n+                }\n             })\n             .transpose()\n             .context(CredentialSnafu)?;\n@@ -1134,8 +1178,12 @@ impl GoogleCloudStorageBuilder {\n         Ok(GoogleCloudStorage {\n             client: Arc::new(GoogleCloudStorageClient {\n                 client,\n-                base_url: credentials.gcs_base_url,\n+                base_url,\n                 oauth_provider,\n+                authentication_manager: AuthenticationManagerW {\n+                    disabled: disable_oauth,\n+                    inner: Mutex::new(None),\n+                },\n                 token_cache: Default::default(),\n                 bucket_name,\n                 bucket_name_encoded: encoded_bucket_name,"
    }
  ],
  "fix_category": NaN,
  "root_cause_category": NaN,
  "root_cause_subcategory": "Not \u2018flaky\u2019"
}