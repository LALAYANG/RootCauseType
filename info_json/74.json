{
  "id": 74,
  "repo": "databend",
  "issue_url": "https://github.com/databendlabs/databend/issues/7986",
  "pr_url": "https://github.com/databendlabs/databend/pull/9104",
  "issue_description": "**Summary**\r\n\r\n```shell\r\n--- /workspace/tests/suites/0_stateless/13_tpch/13_0007_q7.result        2022-09-30 05:37:31.856084133 +0000\r\n+++ /workspace/tests/suites/0_stateless/13_tpch/13_0007_q7.stdout        2022-09-30 05:38:54.725091643 +0000\r\n@@ -1,4 +1 @@\r\n-FRANCE        GERMANY        1995        4637235.15\r\n-FRANCE        GERMANY        1996        5224779.573\r\n-GERMANY        FRANCE        1995        6232818.703\r\n-GERMANY        FRANCE        1996        5557312.112\r\n+ERROR 1105 (HY000) at line 2: Code: 1067, displayText = error reading a body from connection: broken pipe (while in processor thread 0).\r\n```\r\n\r\nhttps://github.com/datafuselabs/databend/actions/runs/3156329493/jobs/5136357403",
  "files_changed": [
    {
      "filename": "scripts/ci/ci-run-stateless-tests-cluster.sh",
      "status": "modified",
      "patch": "@@ -15,5 +15,4 @@ cd \"$SCRIPT_PATH/../../tests\" || exit\n \n echo \"Starting databend-test\"\n # 13_0004_q4: https://github.com/datafuselabs/databend/issues/8107\n-# 13_0005_q5: https://github.com/datafuselabs/databend/issues/7986\n-./databend-test --mode 'cluster' --run-dir 0_stateless --skip '13_0004_q4' --skip '13_0005_q5'\n+./databend-test --mode 'cluster' --run-dir 0_stateless --skip '13_0004_q4'"
    },
    {
      "filename": "src/query/service/src/api/rpc/exchange/exchange_transform.rs",
      "status": "modified",
      "patch": "@@ -264,6 +264,7 @@ impl Processor for ExchangeTransform {\n                 DataPacket::ProgressAndPrecommit { .. } => unreachable!(),\n                 DataPacket::FetchProgressAndPrecommit => unreachable!(),\n                 DataPacket::FragmentData(v) => self.on_recv_data(v),\n+                DataPacket::ClosingClient => Ok(()),\n             };\n         }\n "
    },
    {
      "filename": "src/query/service/src/api/rpc/exchange/exchange_transform_source.rs",
      "status": "modified",
      "patch": "@@ -130,6 +130,7 @@ impl Processor for ExchangeSourceTransform {\n                 DataPacket::FragmentData(v) => self.on_recv_data(v),\n                 DataPacket::FetchProgressAndPrecommit => unreachable!(),\n                 DataPacket::ProgressAndPrecommit { .. } => unreachable!(),\n+                DataPacket::ClosingClient => Ok(()),\n             };\n         }\n "
    },
    {
      "filename": "src/query/service/src/api/rpc/exchange/statistics_receiver.rs",
      "status": "modified",
      "patch": "@@ -139,6 +139,7 @@ impl StatisticsReceiver {\n     fn recv_data(ctx: &Arc<QueryContext>, recv_data: Result<Option<DataPacket>>) -> Result<bool> {\n         match recv_data {\n             Ok(None) => Ok(true),\n+            Ok(Some(DataPacket::ClosingClient)) => Ok(true),\n             Err(transport_error) => Err(transport_error),\n             Ok(Some(DataPacket::ErrorCode(error))) => Err(error),\n             Ok(Some(DataPacket::FragmentData(_))) => unreachable!(),"
    },
    {
      "filename": "src/query/service/src/api/rpc/exchange/statistics_sender.rs",
      "status": "modified",
      "patch": "@@ -90,6 +90,11 @@ impl StatisticsSender {\n                         notified = right;\n                         recv = Box::pin(flight_exchange.recv());\n \n+                        if matches!(command, DataPacket::ClosingClient) {\n+                            ctx.get_exchange_manager().shutdown_query(&query_id);\n+                            return;\n+                        }\n+\n                         if let Err(_cause) = Self::on_command(&ctx, command, &flight_exchange).await\n                         {\n                             ctx.get_exchange_manager().shutdown_query(&query_id);\n@@ -100,6 +105,10 @@ impl StatisticsSender {\n             }\n \n             if let Ok(Some(command)) = flight_exchange.recv().await {\n+                if matches!(command, DataPacket::ClosingClient) {\n+                    return;\n+                }\n+\n                 if let Err(error) = Self::on_command(&ctx, command, &flight_exchange).await {\n                     tracing::warn!(\"Statistics send has error, cause: {:?}.\", error);\n                 }\n@@ -140,6 +149,7 @@ impl StatisticsSender {\n                     })\n                     .await\n             }\n+            DataPacket::ClosingClient => unreachable!(),\n         }\n     }\n "
    },
    {
      "filename": "src/query/service/src/api/rpc/flight_client.rs",
      "status": "modified",
      "patch": "@@ -135,10 +135,18 @@ impl FlightExchange {\n     ) -> FlightExchange {\n         let mut streaming = streaming.into_inner();\n         let (tx, rx) = async_channel::bounded(1);\n+\n         common_base::base::tokio::spawn(async move {\n             while let Some(message) = streaming.next().await {\n-                if let Err(_cause) = tx.send(message).await {\n-                    break;\n+                match message {\n+                    Ok(message) if DataPacket::is_closing_client(&message) => {\n+                        break;\n+                    }\n+                    other => {\n+                        if let Err(_c) = tx.send(other).await {\n+                            break;\n+                        }\n+                    }\n                 }\n             }\n         });\n@@ -159,8 +167,15 @@ impl FlightExchange {\n         let (tx, request_rx) = async_channel::bounded(1);\n         common_base::base::tokio::spawn(async move {\n             while let Some(message) = streaming.next().await {\n-                if let Err(_cause) = tx.send(message).await {\n-                    break;\n+                match message {\n+                    Ok(flight_data) if DataPacket::is_closing_client(&flight_data) => {\n+                        break;\n+                    }\n+                    other => {\n+                        if let Err(_cause) = tx.send(other).await {\n+                            break;\n+                        }\n+                    }\n                 }\n             }\n         });\n@@ -282,7 +297,9 @@ impl ClientFlightExchange {\n         if !self.is_closed_response.fetch_or(true, Ordering::SeqCst)\n             && self.state.response_count.fetch_sub(1, Ordering::AcqRel) == 1\n         {\n-            self.response_tx.close();\n+            let _ = self\n+                .response_tx\n+                .send_blocking(FlightData::from(DataPacket::ClosingClient));\n         }\n     }\n }\n@@ -304,17 +321,8 @@ impl Clone for ClientFlightExchange {\n \n impl Drop for ClientFlightExchange {\n     fn drop(&mut self) {\n-        if !self.is_closed_request.fetch_or(true, Ordering::SeqCst)\n-            && self.state.request_count.fetch_sub(1, Ordering::AcqRel) == 1\n-        {\n-            self.request_rx.close();\n-        }\n-\n-        if !self.is_closed_response.fetch_or(true, Ordering::SeqCst)\n-            && self.state.response_count.fetch_sub(1, Ordering::AcqRel) == 1\n-        {\n-            self.response_tx.close();\n-        }\n+        self.close_input();\n+        self.close_output();\n     }\n }\n \n@@ -398,7 +406,9 @@ impl ServerFlightExchange {\n         if !self.is_closed_response.fetch_or(true, Ordering::SeqCst)\n             && self.state.response_count.fetch_sub(1, Ordering::AcqRel) == 1\n         {\n-            self.response_tx.close();\n+            let _ = self\n+                .response_tx\n+                .send_blocking(Ok(FlightData::from(DataPacket::ClosingClient)));\n         }\n     }\n }"
    },
    {
      "filename": "src/query/service/src/api/rpc/packets/packet_data.rs",
      "status": "modified",
      "patch": "@@ -56,6 +56,18 @@ pub enum DataPacket {\n         progress: Vec<ProgressInfo>,\n         precommit: Vec<PrecommitBlock>,\n     },\n+    // NOTE: Unknown reason. This may be tonic's bug.\n+    // when we use two-way streaming grpc for data exchange,\n+    // if the client side is closed and the server side reads data immediately.\n+    // we will get a broken pipe or connect reset error.\n+    // we use the ClosingClient to notify the server side to close the connection for avoid errors.\n+    ClosingClient,\n+}\n+\n+impl DataPacket {\n+    pub fn is_closing_client(data: &FlightData) -> bool {\n+        data.app_metadata.last() == Some(&0x05)\n+    }\n }\n \n impl From<DataPacket> for FlightData {\n@@ -103,6 +115,12 @@ impl From<DataPacket> for FlightData {\n                     app_metadata: vec![0x04],\n                 }\n             }\n+            DataPacket::ClosingClient => FlightData {\n+                data_body: vec![],\n+                data_header: vec![],\n+                flight_descriptor: None,\n+                app_metadata: vec![0x05],\n+            },\n         }\n     }\n }\n@@ -155,6 +173,7 @@ impl TryFrom<FlightData> for DataPacket {\n                     progress: progress_info,\n                 })\n             }\n+            0x05 => Ok(DataPacket::ClosingClient),\n             _ => Err(ErrorCode::BadBytes(\"Unknown flight data packet type.\")),\n         }\n     }"
    }
  ],
  "fix_category": "Handle error case",
  "root_cause_category": "Network",
  "root_cause_subcategory": "Connection loss"
}