{
  "id": 85,
  "repo": "deltachat-core-rust",
  "issue_url": "https://github.com/deltachat/deltachat-core-rust/issues/3190",
  "pr_url": "https://github.com/deltachat/deltachat-core-rust/pull/3223",
  "issue_description": "mark message as seen on imap in this case.\r\nspams log with events even though the jobs can not be executed because the device is offline.\r\n\r\nproposed solution: don't run the mark msg as read on imap job if offline",
  "files_changed": [
    {
      "filename": "CHANGELOG.md",
      "status": "modified",
      "patch": "@@ -17,6 +17,7 @@\n - `get_connectivity_html()` returns HTML as non-scalable #3213\n - add update-serial to `DC_EVENT_WEBXDC_STATUS_UPDATE` #3215\n - Speed up message receiving via IMAP a bit #3225\n+- mark messages as seen on IMAP in batches #3223\n \n \n ## 1.77.0"
    },
    {
      "filename": "src/dc_receive_imf.rs",
      "status": "modified",
      "patch": "@@ -24,7 +24,7 @@ use crate::download::DownloadState;\n use crate::ephemeral::{stock_ephemeral_timer_changed, Timer as EphemeralTimer};\n use crate::events::EventType;\n use crate::headerdef::{HeaderDef, HeaderDefMap};\n-use crate::job::{self, Action};\n+use crate::imap::markseen_on_imap_table;\n use crate::location;\n use crate::log::LogExt;\n use crate::message::{\n@@ -339,16 +339,7 @@ pub(crate) async fn dc_receive_imf_inner(\n                 .await?;\n         } else if !mime_parser.mdn_reports.is_empty() && mime_parser.has_chat_version() {\n             // This is a Delta Chat MDN. Mark as read.\n-            job::add(\n-                context,\n-                job::Job::new(\n-                    Action::MarkseenMsgOnImap,\n-                    insert_msg_id.to_u32(),\n-                    Params::new(),\n-                    0,\n-                ),\n-            )\n-            .await?;\n+            markseen_on_imap_table(context, rfc724_mid).await?;\n         }\n     }\n \n@@ -2300,6 +2291,7 @@ mod tests {\n     use crate::chat::{get_chat_msgs, ChatItem, ChatVisibility};\n     use crate::chatlist::Chatlist;\n     use crate::constants::DC_GCL_NO_SPECIALS;\n+    use crate::imap::prefetch_should_download;\n     use crate::message::Message;\n     use crate::test_utils::{get_chat_msg, TestContext, TestContextManager};\n \n@@ -2883,7 +2875,7 @@ mod tests {\n \n         // Check that the ndn would be downloaded:\n         let headers = mailparse::parse_mail(raw_ndn).unwrap().headers;\n-        assert!(crate::imap::prefetch_should_download(\n+        assert!(prefetch_should_download(\n             &t,\n             &headers,\n             \"some-other-message-id\","
    },
    {
      "filename": "src/imap.rs",
      "status": "modified",
      "patch": "@@ -7,6 +7,7 @@ use std::{\n     cmp,\n     cmp::max,\n     collections::{BTreeMap, BTreeSet},\n+    iter::Peekable,\n };\n \n use anyhow::{bail, format_err, Context as _, Result};\n@@ -31,14 +32,13 @@ use crate::dc_receive_imf::{\n use crate::dc_tools::dc_create_id;\n use crate::events::EventType;\n use crate::headerdef::{HeaderDef, HeaderDefMap};\n-use crate::job::{self, Action};\n+use crate::job;\n use crate::login_param::{\n     CertificateChecks, LoginParam, ServerAddress, ServerLoginParam, Socks5Config,\n };\n use crate::message::{self, Message, MessageState, MessengerMessage, MsgId, Viewtype};\n use crate::mimeparser;\n use crate::oauth2::dc_get_oauth2_access_token;\n-use crate::param::Params;\n use crate::provider::Socket;\n use crate::scheduler::connectivity::ConnectivityStore;\n use crate::scheduler::InterruptInfo;\n@@ -165,6 +165,67 @@ struct ImapConfig {\n     pub can_condstore: bool,\n }\n \n+struct UidGrouper<T: Iterator<Item = (i64, u32, String)>> {\n+    inner: Peekable<T>,\n+}\n+\n+impl<T, I> From<I> for UidGrouper<T>\n+where\n+    T: Iterator<Item = (i64, u32, String)>,\n+    I: IntoIterator<IntoIter = T>,\n+{\n+    fn from(inner: I) -> Self {\n+        Self {\n+            inner: inner.into_iter().peekable(),\n+        }\n+    }\n+}\n+\n+impl<T: Iterator<Item = (i64, u32, String)>> Iterator for UidGrouper<T> {\n+    // Tuple of folder, row IDs, and UID range as a string.\n+    type Item = (String, Vec<i64>, String);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let (_, _, folder) = self.inner.peek().cloned()?;\n+\n+        let mut uid_set = String::new();\n+        let mut rowid_set = Vec::new();\n+\n+        while uid_set.len() < 1000 {\n+            // Construct a new range.\n+            if let Some((start_rowid, start_uid, _)) = self\n+                .inner\n+                .next_if(|(_, _, start_folder)| start_folder == &folder)\n+            {\n+                rowid_set.push(start_rowid);\n+                let mut end_uid = start_uid;\n+\n+                while let Some((next_rowid, next_uid, _)) =\n+                    self.inner.next_if(|(_, next_uid, next_folder)| {\n+                        next_folder == &folder && *next_uid == end_uid + 1\n+                    })\n+                {\n+                    end_uid = next_uid;\n+                    rowid_set.push(next_rowid);\n+                }\n+\n+                let uid_range = UidRange {\n+                    start: start_uid,\n+                    end: end_uid,\n+                };\n+                if !uid_set.is_empty() {\n+                    uid_set.push(',');\n+                }\n+                uid_set.push_str(&uid_range.to_string());\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        Some((folder, rowid_set, uid_set))\n+    }\n+}\n+\n impl Imap {\n     /// Creates new disconnected IMAP client using the specific login parameters.\n     ///\n@@ -944,7 +1005,7 @@ impl Imap {\n     ///\n     /// This is the only place where messages are moved or deleted on the IMAP server.\n     async fn move_delete_messages(&mut self, context: &Context, folder: &str) -> Result<()> {\n-        let mut rows = context\n+        let rows = context\n             .sql\n             .query_map(\n                 \"SELECT id, uid, target FROM imap\n@@ -960,48 +1021,12 @@ impl Imap {\n                 },\n                 |rows| rows.collect::<Result<Vec<_>, _>>().map_err(Into::into),\n             )\n-            .await?\n-            .into_iter()\n-            .peekable();\n+            .await?;\n \n         self.prepare(context).await?;\n         self.select_folder(context, Some(folder)).await?;\n \n-        while let Some((_, _, target)) = rows.peek().cloned() {\n-            // Construct next request for the target folder.\n-            let mut uid_set = String::new();\n-            let mut rowid_set = Vec::new();\n-\n-            while uid_set.len() < 1000 {\n-                // Construct a new range.\n-                if let Some((start_rowid, start_uid, _)) =\n-                    rows.next_if(|(_, _, start_target)| start_target == &target)\n-                {\n-                    rowid_set.push(start_rowid);\n-                    let mut end_uid = start_uid;\n-\n-                    while let Some((next_rowid, next_uid, _)) =\n-                        rows.next_if(|(_, next_uid, next_target)| {\n-                            next_target == &target && *next_uid == end_uid + 1\n-                        })\n-                    {\n-                        end_uid = next_uid;\n-                        rowid_set.push(next_rowid);\n-                    }\n-\n-                    let uid_range = UidRange {\n-                        start: start_uid,\n-                        end: end_uid,\n-                    };\n-                    if !uid_set.is_empty() {\n-                        uid_set.push(',');\n-                    }\n-                    uid_set.push_str(&uid_range.to_string());\n-                } else {\n-                    break;\n-                }\n-            }\n-\n+        for (target, rowid_set, uid_set) in UidGrouper::from(rows) {\n             // Empty target folder name means messages should be deleted.\n             if target.is_empty() {\n                 self.delete_message_batch(context, &uid_set, rowid_set)\n@@ -1028,6 +1053,62 @@ impl Imap {\n         Ok(())\n     }\n \n+    /// Stores pending `\\Seen` flags for messages in `imap_markseen` table.\n+    pub(crate) async fn store_seen_flags_on_imap(&mut self, context: &Context) -> Result<()> {\n+        self.prepare(context).await?;\n+\n+        let rows = context\n+            .sql\n+            .query_map(\n+                \"SELECT imap.id, uid, folder FROM imap, imap_markseen\n+                 WHERE imap.id = imap_markseen.id AND target = folder\n+                 ORDER BY folder, uid\",\n+                [],\n+                |row| {\n+                    let rowid: i64 = row.get(0)?;\n+                    let uid: u32 = row.get(1)?;\n+                    let folder: String = row.get(2)?;\n+                    Ok((rowid, uid, folder))\n+                },\n+                |rows| rows.collect::<Result<Vec<_>, _>>().map_err(Into::into),\n+            )\n+            .await?;\n+\n+        for (folder, rowid_set, uid_set) in UidGrouper::from(rows) {\n+            self.select_folder(context, Some(&folder))\n+                .await\n+                .context(\"failed to select folder\")?;\n+\n+            if let Err(err) = self.add_flag_finalized_with_set(&uid_set, \"\\\\Seen\").await {\n+                warn!(\n+                    context,\n+                    \"Cannot mark messages {} in folder {} as seen, will retry later: {}.\",\n+                    uid_set,\n+                    folder,\n+                    err\n+                );\n+            } else {\n+                info!(\n+                    context,\n+                    \"Marked messages {} in folder {} as seen.\", uid_set, folder\n+                );\n+                context\n+                    .sql\n+                    .execute(\n+                        format!(\n+                            \"DELETE FROM imap_markseen WHERE id IN ({})\",\n+                            sql::repeat_vars(rowid_set.len())?\n+                        ),\n+                        rusqlite::params_from_iter(rowid_set),\n+                    )\n+                    .await\n+                    .context(\"cannot remove messages marked as seen from imap_markseen table\")?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Synchronizes `\\Seen` flags using `CONDSTORE` extension.\n     pub(crate) async fn sync_seen_flags(&mut self, context: &Context, folder: &str) -> Result<()> {\n         if !self.config.can_condstore {\n@@ -1364,11 +1445,6 @@ impl Imap {\n     /// the flag, or other imap-errors, returns true as well.\n     ///\n     /// Returning error means that the operation can be retried.\n-    async fn add_flag_finalized(&mut self, server_uid: u32, flag: &str) -> Result<()> {\n-        let s = server_uid.to_string();\n-        self.add_flag_finalized_with_set(&s, flag).await\n-    }\n-\n     async fn add_flag_finalized_with_set(&mut self, uid_set: &str, flag: &str) -> Result<()> {\n         if self.should_reconnect() {\n             bail!(\"Can't set flag, should reconnect\");\n@@ -1386,7 +1462,7 @@ impl Imap {\n         Ok(())\n     }\n \n-    pub async fn prepare_imap_operation_on_msg(\n+    pub(crate) async fn prepare_imap_operation_on_msg(\n         &mut self,\n         context: &Context,\n         folder: &str,\n@@ -1426,32 +1502,6 @@ impl Imap {\n         }\n     }\n \n-    pub(crate) async fn set_seen(\n-        &mut self,\n-        context: &Context,\n-        folder: &str,\n-        uid: u32,\n-    ) -> ImapActionResult {\n-        if let Some(imapresult) = self\n-            .prepare_imap_operation_on_msg(context, folder, uid)\n-            .await\n-        {\n-            return imapresult;\n-        }\n-        // we are connected, and the folder is selected\n-        info!(context, \"Marking message {}/{} as seen...\", folder, uid,);\n-\n-        if let Err(err) = self.add_flag_finalized(uid, \"\\\\Seen\").await {\n-            warn!(\n-                context,\n-                \"Cannot mark message {} in folder {} as seen, ignoring: {}.\", uid, folder, err\n-            );\n-            ImapActionResult::Failed\n-        } else {\n-            ImapActionResult::Success\n-        }\n-    }\n-\n     pub async fn ensure_configured_folders(\n         &mut self,\n         context: &Context,\n@@ -1882,13 +1932,11 @@ pub(crate) async fn prefetch_should_download(\n     mut flags: impl Iterator<Item = Flag<'_>>,\n     show_emails: ShowEmails,\n ) -> Result<bool> {\n-    if let Some(msg_id) = message::rfc724_mid_exists(context, message_id).await? {\n-        // We know the Message-ID already, it must be a Bcc: to self.\n-        job::add(\n-            context,\n-            job::Job::new(Action::MarkseenMsgOnImap, msg_id.to_u32(), Params::new(), 0),\n-        )\n-        .await?;\n+    if message::rfc724_mid_exists(context, message_id)\n+        .await?\n+        .is_some()\n+    {\n+        markseen_on_imap_table(context, message_id).await?;\n         return Ok(false);\n     }\n \n@@ -2022,6 +2070,22 @@ async fn mark_seen_by_uid(\n     }\n }\n \n+/// Schedule marking the message as Seen on IMAP by adding all known IMAP messages corresponding to\n+/// the given Message-ID to `imap_markseen` table.\n+pub(crate) async fn markseen_on_imap_table(context: &Context, message_id: &str) -> Result<()> {\n+    context\n+        .sql\n+        .execute(\n+            \"INSERT OR IGNORE INTO imap_markseen (id)\n+             SELECT id FROM imap WHERE rfc724_mid=?\",\n+            paramsv![message_id],\n+        )\n+        .await?;\n+    context.interrupt_inbox(InterruptInfo::new(false)).await;\n+\n+    Ok(())\n+}\n+\n /// uid_next is the next unique identifier value from the last time we fetched a folder\n /// See <https://tools.ietf.org/html/rfc3501#section-2.3.1.1>\n /// This function is used to update our uid_next after fetching messages."
    },
    {
      "filename": "src/job.rs",
      "status": "modified",
      "patch": "@@ -13,7 +13,7 @@ use crate::contact::{normalize_name, Contact, ContactId, Modifier, Origin};\n use crate::context::Context;\n use crate::dc_tools::time;\n use crate::events::EventType;\n-use crate::imap::{Imap, ImapActionResult};\n+use crate::imap::Imap;\n use crate::location;\n use crate::log::LogExt;\n use crate::message::{Message, MsgId};\n@@ -86,7 +86,6 @@ pub enum Action {\n     // Jobs in the INBOX-thread, range from DC_IMAP_THREAD..DC_IMAP_THREAD+999\n     Housekeeping = 105, // low priority ...\n     FetchExistingMsgs = 110,\n-    MarkseenMsgOnImap = 130,\n \n     // this is user initiated so it should have a fairly high priority\n     UpdateRecentQuota = 140,\n@@ -123,7 +122,6 @@ impl From<Action> for Thread {\n             Housekeeping => Thread::Imap,\n             FetchExistingMsgs => Thread::Imap,\n             ResyncFolders => Thread::Imap,\n-            MarkseenMsgOnImap => Thread::Imap,\n             UpdateRecentQuota => Thread::Imap,\n             DownloadMsg => Thread::Imap,\n \n@@ -403,67 +401,6 @@ impl Job {\n             Status::Finished(Ok(()))\n         }\n     }\n-\n-    async fn markseen_msg_on_imap(&mut self, context: &Context, imap: &mut Imap) -> Status {\n-        if let Err(err) = imap.prepare(context).await {\n-            warn!(context, \"could not connect: {:?}\", err);\n-            return Status::RetryLater;\n-        }\n-\n-        let msg = job_try!(Message::load_from_db(context, MsgId::new(self.foreign_id)).await);\n-        let row = job_try!(\n-            context\n-                .sql\n-                .query_row_optional(\n-                    \"SELECT uid, folder FROM imap\n-                    WHERE rfc724_mid=? AND folder=target\n-                    ORDER BY uid ASC\n-                    LIMIT 1\",\n-                    paramsv![msg.rfc724_mid],\n-                    |row| {\n-                        let uid: u32 = row.get(0)?;\n-                        let folder: String = row.get(1)?;\n-                        Ok((uid, folder))\n-                    }\n-                )\n-                .await\n-        );\n-        if let Some((server_uid, server_folder)) = row {\n-            let result = imap.set_seen(context, &server_folder, server_uid).await;\n-            match result {\n-                ImapActionResult::RetryLater => return Status::RetryLater,\n-                ImapActionResult::Success | ImapActionResult::Failed => {}\n-            }\n-        } else {\n-            info!(\n-                context,\n-                \"Can't mark the message {} as seen on IMAP because there is no known UID\",\n-                msg.rfc724_mid\n-            );\n-        }\n-\n-        // XXX we send MDN even in case of failure to mark the messages as seen, e.g. if it was\n-        // already deleted on the server by another device. The job will not be retried so locally\n-        // there is no risk of double-sending MDNs.\n-        //\n-        // Read receipts for system messages are never sent. These messages have no place to\n-        // display received read receipt anyway.  And since their text is locally generated,\n-        // quoting them is dangerous as it may contain contact names. E.g., for original message\n-        // \"Group left by me\", a read receipt will quote \"Group left by <name>\", and the name can\n-        // be a display name stored in address book rather than the name sent in the From field by\n-        // the user.\n-        if msg.param.get_bool(Param::WantsMdn).unwrap_or_default() && !msg.is_system_message() {\n-            let mdns_enabled = job_try!(context.get_config_bool(Config::MdnsEnabled).await);\n-            if mdns_enabled {\n-                if let Err(err) = send_mdn(context, &msg).await {\n-                    warn!(context, \"could not send out mdn for {}: {}\", msg.id, err);\n-                    return Status::Finished(Err(err));\n-                }\n-            }\n-        }\n-\n-        Status::Finished(Ok(()))\n-    }\n }\n \n /// Delete all pending jobs with the given action.\n@@ -660,7 +597,6 @@ async fn perform_job_action(\n             location::job_maybe_send_locations_ended(context, job).await\n         }\n         Action::ResyncFolders => job.resync_folders(context, connection.inbox()).await,\n-        Action::MarkseenMsgOnImap => job.markseen_msg_on_imap(context, connection.inbox()).await,\n         Action::FetchExistingMsgs => job.fetch_existing_msgs(context, connection.inbox()).await,\n         Action::Housekeeping => {\n             sql::housekeeping(context).await.ok_or_log(context);\n@@ -698,13 +634,13 @@ fn get_backoff_time_offset(tries: u32, action: Action) -> i64 {\n     }\n }\n \n-async fn send_mdn(context: &Context, msg: &Message) -> Result<()> {\n+pub(crate) async fn send_mdn(context: &Context, msg_id: MsgId, from_id: ContactId) -> Result<()> {\n     let mut param = Params::new();\n-    param.set(Param::MsgId, msg.id.to_u32().to_string());\n+    param.set(Param::MsgId, msg_id.to_u32().to_string());\n \n     add(\n         context,\n-        Job::new(Action::SendMdn, msg.from_id.to_u32(), param, 0),\n+        Job::new(Action::SendMdn, from_id.to_u32(), param, 0),\n     )\n     .await?;\n \n@@ -732,7 +668,6 @@ pub async fn add(context: &Context, job: Job) -> Result<()> {\n             Action::Unknown => unreachable!(),\n             Action::Housekeeping\n             | Action::ResyncFolders\n-            | Action::MarkseenMsgOnImap\n             | Action::FetchExistingMsgs\n             | Action::UpdateRecentQuota\n             | Action::DownloadMsg => {"
    },
    {
      "filename": "src/message.rs",
      "status": "modified",
      "patch": "@@ -9,6 +9,7 @@ use rusqlite::types::ValueRef;\n use serde::{Deserialize, Serialize};\n \n use crate::chat::{self, Chat, ChatId};\n+use crate::config::Config;\n use crate::constants::{\n     Blocked, Chattype, VideochatType, DC_CHAT_ID_TRASH, DC_DESIRED_TEXT_LEN, DC_MSG_ID_LAST_SPECIAL,\n };\n@@ -21,6 +22,7 @@ use crate::dc_tools::{\n use crate::download::DownloadState;\n use crate::ephemeral::{start_ephemeral_timers_msgids, Timer as EphemeralTimer};\n use crate::events::EventType;\n+use crate::imap::markseen_on_imap_table;\n use crate::job::{self, Action};\n use crate::log::LogExt;\n use crate::mimeparser::{parse_message_id, FailureReport, SystemMessage};\n@@ -1294,6 +1296,9 @@ pub async fn markseen_msgs(context: &Context, msg_ids: Vec<MsgId>) -> Result<()>\n                     m.chat_id AS chat_id,\n                     m.state AS state,\n                     m.ephemeral_timer AS ephemeral_timer,\n+                    m.param AS param,\n+                    m.from_id AS from_id,\n+                    m.rfc724_mid AS rfc724_mid,\n                     c.blocked AS blocked\n                  FROM msgs m LEFT JOIN chats c ON c.id=m.chat_id\n                  WHERE m.id IN ({}) AND m.chat_id>9\",\n@@ -1304,12 +1309,18 @@ pub async fn markseen_msgs(context: &Context, msg_ids: Vec<MsgId>) -> Result<()>\n                 let id: MsgId = row.get(\"id\")?;\n                 let chat_id: ChatId = row.get(\"chat_id\")?;\n                 let state: MessageState = row.get(\"state\")?;\n+                let param: Params = row.get::<_, String>(\"param\")?.parse().unwrap_or_default();\n+                let from_id: ContactId = row.get(\"from_id\")?;\n+                let rfc724_mid: String = row.get(\"rfc724_mid\")?;\n                 let blocked: Option<Blocked> = row.get(\"blocked\")?;\n                 let ephemeral_timer: EphemeralTimer = row.get(\"ephemeral_timer\")?;\n                 Ok((\n                     id,\n                     chat_id,\n                     state,\n+                    param,\n+                    from_id,\n+                    rfc724_mid,\n                     blocked.unwrap_or_default(),\n                     ephemeral_timer,\n                 ))\n@@ -1318,30 +1329,52 @@ pub async fn markseen_msgs(context: &Context, msg_ids: Vec<MsgId>) -> Result<()>\n         )\n         .await?;\n \n-    if msgs\n-        .iter()\n-        .any(|(_id, _chat_id, _state, _blocked, ephemeral_timer)| {\n+    if msgs.iter().any(\n+        |(_id, _chat_id, _state, _param, _from_id, _rfc724_mid, _blocked, ephemeral_timer)| {\n             *ephemeral_timer != EphemeralTimer::Disabled\n-        })\n-    {\n+        },\n+    ) {\n         start_ephemeral_timers_msgids(context, &msg_ids)\n             .await\n             .context(\"failed to start ephemeral timers\")?;\n     }\n \n     let mut updated_chat_ids = BTreeSet::new();\n-    for (id, curr_chat_id, curr_state, curr_blocked, _curr_ephemeral_timer) in msgs.into_iter() {\n+    for (\n+        id,\n+        curr_chat_id,\n+        curr_state,\n+        curr_param,\n+        curr_from_id,\n+        curr_rfc724_mid,\n+        curr_blocked,\n+        _curr_ephemeral_timer,\n+    ) in msgs.into_iter()\n+    {\n         if curr_blocked == Blocked::Not\n             && (curr_state == MessageState::InFresh || curr_state == MessageState::InNoticed)\n         {\n             update_msg_state(context, id, MessageState::InSeen).await?;\n             info!(context, \"Seen message {}.\", id);\n \n-            job::add(\n-                context,\n-                job::Job::new(Action::MarkseenMsgOnImap, id.to_u32(), Params::new(), 0),\n-            )\n-            .await?;\n+            markseen_on_imap_table(context, &curr_rfc724_mid).await?;\n+\n+            // Read receipts for system messages are never sent. These messages have no place to\n+            // display received read receipt anyway.  And since their text is locally generated,\n+            // quoting them is dangerous as it may contain contact names. E.g., for original message\n+            // \"Group left by me\", a read receipt will quote \"Group left by <name>\", and the name can\n+            // be a display name stored in address book rather than the name sent in the From field by\n+            // the user.\n+            if curr_param.get_bool(Param::WantsMdn).unwrap_or_default()\n+                && curr_param.get_cmd() == SystemMessage::Unknown\n+            {\n+                let mdns_enabled = context.get_config_bool(Config::MdnsEnabled).await?;\n+                if mdns_enabled {\n+                    if let Err(err) = job::send_mdn(context, id, curr_from_id).await {\n+                        warn!(context, \"could not send out mdn for {}: {}\", id, err);\n+                    }\n+                }\n+            }\n             updated_chat_ids.insert(curr_chat_id);\n         }\n     }"
    },
    {
      "filename": "src/scheduler.rs",
      "status": "modified",
      "patch": "@@ -168,6 +168,16 @@ async fn fetch_idle(ctx: &Context, connection: &mut Imap, folder: Config) -> Int\n                 return connection.fake_idle(ctx, Some(watch_folder)).await;\n             }\n \n+            if folder == Config::ConfiguredInboxFolder {\n+                if let Err(err) = connection\n+                    .store_seen_flags_on_imap(ctx)\n+                    .await\n+                    .context(\"store_seen_flags_on_imap failed\")\n+                {\n+                    warn!(ctx, \"{:#}\", err);\n+                }\n+            }\n+\n             // Fetch the watched folder.\n             if let Err(err) = connection.fetch_move_delete(ctx, &watch_folder).await {\n                 connection.trigger_reconnect(ctx).await;"
    },
    {
      "filename": "src/sql.rs",
      "status": "modified",
      "patch": "@@ -181,6 +181,7 @@ impl Sql {\n                      PRAGMA secure_delete=on;\n                      PRAGMA busy_timeout = {};\n                      PRAGMA temp_store=memory; -- Avoid SQLITE_IOERR_GETTEMPPATH errors on Android\n+                     PRAGMA foreign_keys=on;\n                      \",\n                     Duration::from_secs(10).as_millis()\n                 ))?;"
    },
    {
      "filename": "src/sql/migrations.rs",
      "status": "modified",
      "patch": "@@ -613,6 +613,17 @@ CREATE INDEX smtp_messageid ON imap(rfc724_mid);\n         sql.execute_migration(\"DROP TABLE IF EXISTS backup_blobs;\", 88)\n             .await?;\n     }\n+    if dbversion < 89 {\n+        info!(context, \"[migration] v89\");\n+        sql.execute_migration(\n+            r#\"CREATE TABLE imap_markseen (\n+              id INTEGER,\n+              FOREIGN KEY(id) REFERENCES imap(id) ON DELETE CASCADE\n+            );\"#,\n+            89,\n+        )\n+        .await?;\n+    }\n \n     Ok((\n         recalc_fingerprints,"
    }
  ],
  "fix_category": "Queueing",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": "Race Condition"
}